<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vocal Reminder App</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <!-- Font Awesome for icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            min-height: 100vh;
            background-color: #f7f9fc;
        }
        .mic-button {
            transition: all 0.2s ease;
        }
        .mic-button:hover {
            transform: scale(1.05);
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
        }
        .listening {
            animation: pulse-ring 1.5s infinite;
        }
        @keyframes pulse-ring {
            0% { box-shadow: 0 0 0 0 rgba(76, 29, 149, 0.4); }
            70% { box-shadow: 0 0 0 10px rgba(76, 29, 149, 0); }
            100% { box-shadow: 0 0 0 0 rgba(76, 29, 149, 0); }
        }
        .pen-button {
            transition: transform 0.1s ease;
        }
        .pen-button:active {
            transform: scale(0.95);
        }
    </style>
</head>
<body class="p-4 sm:p-8 flex flex-col items-center">

    <!-- Main Container -->
    <div class="w-full max-w-xl">

        <h1 class="text-3xl font-bold text-gray-800 text-center mb-6">Vocal Reminder</h1>
        
        <!-- Status Message Area -->
        <div id="status-message" class="p-3 text-sm text-center rounded-lg mb-6 transition-all duration-300 min-h-[40px] flex items-center justify-center bg-blue-100 text-blue-800 border border-blue-200">
            Reminder app running. Reminders are saved for this session only.
        </div>

        <!-- Microphone Input Area -->
        <div class="flex flex-col items-center space-y-4 mb-8">
            <button id="mic-button" class="mic-button w-24 h-24 rounded-full bg-indigo-600 text-white flex items-center justify-center shadow-lg transition duration-150 ease-in-out">
                <i class="fas fa-microphone text-3xl"></i>
            </button>
            <p id="mic-status" class="text-sm text-gray-500 font-medium">Click to Speak</p>
        </div>

        <!-- Manual Text Input -->
        <div class="text-input-group flex space-x-2">
            <input type="text" id="reminder-input" placeholder='e.g., "Drink water in 5 seconds"' class="flex-grow p-3 border border-gray-300 rounded-lg focus:ring-indigo-500 focus:border-indigo-500 shadow-sm transition duration-150 ease-in-out" />
            <button id="set-manual-btn" class="pen-button p-3 bg-white text-indigo-600 border border-gray-300 rounded-lg shadow-sm hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-indigo-500">
                <i class="fas fa-pen text-xl"></i>
            </button>
        </div>
        <p class="text-xs text-gray-400 mt-2 text-center">Use format: [Task] [on/in/at] [Time Phrase]</p>

        <hr class="my-8 border-gray-200">

        <!-- Reminder List -->
        <h2 class="text-2xl font-semibold text-gray-800 mb-4">Upcoming Reminders</h2>
        <div id="reminders-list" class="space-y-3">
            <!-- Reminders will be injected here -->
            <p id="no-reminders" class="text-center text-gray-500 p-4 bg-white rounded-lg shadow-md">No reminders set yet.</p>
        </div>
    </div>

    <script>
        // --- GLOBAL SETUP (NO STORAGE, NO MODAL) ---
        let reminders = []; // Session-only array
        let recognition = null; 
        let triggeredReminders = new Set(); // Tracks reminders that have been announced via TTS

        // --- DOM Elements ---
        const STATUS_MESSAGE = document.getElementById('status-message');
        const REMINDERS_LIST = document.getElementById('reminders-list');
        const REMINDER_INPUT = document.getElementById('reminder-input');
        const SET_MANUAL_BTN = document.getElementById('set-manual-btn');
        const MIC_BUTTON = document.getElementById('mic-button');
        const MIC_STATUS = document.getElementById('mic-status');

        // --- Utility Functions ---

        /**
         * Formats a timestamp into a human-readable date and time string.
         * @param {number} timestamp
         * @returns {string} Formatted time string
         */
        const formatTime = (timestamp) => {
            const date = new Date(timestamp);
            return date.toLocaleString([], {
                year: 'numeric',
                month: 'short',
                day: 'numeric',
                hour: '2-digit',
                minute: '2-digit'
            });
        };

        /**
         * Displays a status message to the user.
         * @param {string} message The message to display.
         * @param {boolean} isError If true, displays as an error.
         */
        const setStatus = (message, isError) => {
            STATUS_MESSAGE.textContent = message;
            STATUS_MESSAGE.className = 'p-3 text-sm text-center rounded-lg mb-6 transition-all duration-300 min-h-[40px] flex items-center justify-center';
            if (isError) {
                STATUS_MESSAGE.classList.add('bg-red-100', 'text-red-800', 'border', 'border-red-200');
            } else {
                STATUS_MESSAGE.classList.add('bg-blue-100', 'text-blue-800', 'border', 'border-blue-200');
            }
        };

        // --- Reminder Management (Session Only) ---

        /**
         * Adds a new reminder to the local array and triggers a UI update.
         * @param {string} text Reminder text.
         * @param {number} timestamp Target timestamp in milliseconds.
         */
        const addReminder = (text, timestamp) => {
            const newId = Date.now().toString() + Math.random().toString(36).substring(2, 9);
            reminders.push({
                id: newId,
                text: text,
                timestamp: timestamp,
                createdAt: Date.now()
            });
            // Keep sorted for display purposes
            reminders.sort((a, b) => a.timestamp - b.timestamp);
            renderReminders();
            setStatus(`Reminder set for: ${formatTime(timestamp)}`, false);
        };

        /**
         * Deletes a reminder from the local array and triggers a UI update.
         * @param {string} id Unique ID of the reminder to delete.
         */
        const deleteReminder = (id) => {
            reminders = reminders.filter(r => r.id !== id);
            // Clean up the set of triggered reminders
            triggeredReminders.delete(id); 
            renderReminders();
        };

        // --- Core Logic: Time Parsing ---

        /**
         * Parses a natural language time phrase into a future UTC timestamp.
         * (This logic is crucial for both manual and voice input)
         * @param {string} phrase The time phrase (e.g., "5 seconds", "2 hours").
         * @returns {number | null} Future UTC timestamp in milliseconds, or null if parsing fails.
         */
        const parseReminderTime = (phrase) => {
            const lowerPhrase = phrase.toLowerCase().trim();
            const now = new Date();
            let targetTime = null;

            // 1. Relative Time Parsing (e.g., "5 seconds", "2 hours", "3 days")
            const relativeMatch = lowerPhrase.match(/(\d+)\s+(second|minute|hour|day|week)s?/i);

            if (relativeMatch) {
                const value = parseInt(relativeMatch[1], 10);
                const unit = relativeMatch[2];
                targetTime = new Date(now.getTime());

                switch (unit) {
                    case 'second':
                        targetTime.setSeconds(now.getSeconds() + value);
                        break;
                    case 'minute':
                        targetTime.setMinutes(now.getMinutes() + value);
                        break;
                    case 'hour':
                        targetTime.setHours(now.getHours() + value);
                        break;
                    case 'day':
                        targetTime.setDate(now.getDate() + value);
                        break;
                    case 'week':
                        targetTime.setDate(now.getDate() + (value * 7));
                        break;
                    default:
                        return null;
                }
                
                if (targetTime.getTime() > now.getTime()) {
                    return targetTime.getTime();
                }
            }

            // 2. Specific Time/Date Parsing (e.g., "tomorrow at 5pm", "4:30 PM")
            try {
                let parsedDate = new Date(phrase);
                
                if (!isNaN(parsedDate.getTime())) {
                    if (parsedDate.getTime() <= now.getTime()) {
                        // If only a time was specified (e.g., "5 PM"), set it for tomorrow.
                        const timeOnly = parsedDate.toDateString() === now.toDateString();
                        if (timeOnly) {
                            parsedDate.setDate(parsedDate.getDate() + 1);
                        } else {
                            return null;
                        }
                    }
                    targetTime = parsedDate;
                }
            } catch (e) {
                // Ignore date parsing errors
            }

            if (targetTime && targetTime.getTime() > now.getTime()) {
                return targetTime.getTime();
            }

            // If all parsing fails
            setStatus(`Couldn't understand the time phrase "${phrase}". Please be more specific.`, true);
            return null;
        };

        // --- UI Rendering ---

        /**
         * Renders the current list of reminders to the DOM.
         */
        const renderReminders = () => {
            REMINDERS_LIST.innerHTML = '';
            
            // Filter out reminders that have been marked as "triggered" AND are past due
            const activeReminders = reminders.filter(r => {
                // Keep all future reminders, and keep past reminders that haven't been deleted yet.
                return true; 
            }); 
            
            if (activeReminders.length === 0) {
                REMINDERS_LIST.innerHTML = '<p id="no-reminders" class="text-center text-gray-500 p-4 bg-white rounded-lg shadow-md">No reminders set yet.</p>';
                return;
            }

            activeReminders.forEach(r => {
                const isDue = triggeredReminders.has(r.id);
                
                const reminderElement = document.createElement('div');
                // Apply visual alert style for due reminders
                reminderElement.className = `p-4 flex items-center justify-between rounded-lg shadow-md transition duration-150 
                    ${isDue ? 'bg-red-100 border-l-4 border-red-500 hover:shadow-xl' : 'bg-white hover:shadow-lg'}`;
                    
                reminderElement.innerHTML = `
                    <div>
                        <p class="font-medium ${isDue ? 'text-red-800 font-bold' : 'text-gray-800'} break-words">${r.text}</p>
                        <p class="text-xs ${isDue ? 'text-red-600 font-bold' : 'text-indigo-500'} mt-1">
                            ${isDue ? 'DUE NOW! (Dismiss Below)' : formatTime(r.timestamp)}
                        </p>
                    </div>
                    <button data-id="${r.id}" class="delete-btn text-gray-400 hover:text-red-600 ml-4 p-2 transition duration-150">
                        <i class="fas fa-trash-alt"></i>
                    </button>
                `;
                REMINDERS_LIST.appendChild(reminderElement);
            });

            // Attach delete listeners
            document.querySelectorAll('.delete-btn').forEach(button => {
                button.onclick = (e) => {
                    const id = e.currentTarget.getAttribute('data-id');
                    deleteReminder(id);
                    setStatus("Reminder deleted.", false);
                };
            });
        };

        // --- Main Loop (Checking Alarms for TTS and Visual Alert) ---

        const mainLoop = () => {
            const now = Date.now();
            reminders.forEach(r => {
                if (r.timestamp < now && !triggeredReminders.has(r.id)) {
                    // New, due reminder found!
                    triggeredReminders.add(r.id);
                    
                    setStatus(`ALERT: ${r.text} is DUE NOW! Please delete it from the list.`, true);

                    // Announce it via TTS once
                    if ('speechSynthesis' in window) {
                        window.speechSynthesis.cancel();
                        let utterance = new SpeechSynthesisUtterance(`Reminder: ${r.text}`);
                        window.speechSynthesis.speak(utterance);
                    }
                    
                    // Re-render to apply the red/yellow "DUE NOW" style
                    renderReminders(); 
                }
            });
        };

        // --- Input Handling ---

        /**
         * Handles manual text input submission. THIS IS THE CORE FIX.
         */
        const handleManualSet = () => {
            const inputContent = REMINDER_INPUT.value.trim();
            if (!inputContent) { return; }

            // Tries to match: "[task] (on|in|at) [time phrase]"
            const match = inputContent.match(/(.+?)\s+(?:on|in|at)\s+(.+)/i);

            if (match && match.length === 3) {
                const text = match[1].trim();
                const timePhrase = match[2].trim();
                
                // Keep the input text if time parsing fails, so user can easily correct the time.
                REMINDER_INPUT.value = text + ' ' + timePhrase; 
                
                const time = parseReminderTime(timePhrase);
                
                if (time) {
                    addReminder(text, time);
                    REMINDER_INPUT.value = ''; // Clear only on successful addition
                }
            } else {
                setStatus("Input format error. Please use: [Task] [on/in/at] [Time Phrase]", true);
            }
        };

        // --- Speech Recognition ---

        const setupSpeechRecognition = () => {
            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;

            if (SpeechRecognition) {
                recognition = new SpeechRecognition();
                recognition.continuous = false;
                recognition.lang = 'en-US';
                recognition.interimResults = false;
                recognition.maxAlternatives = 1;

                MIC_BUTTON.onclick = () => {
                    try {
                        recognition.start();
                    } catch (e) {
                        console.warn("Speech recognition already running or error starting:", e);
                    }
                };

                recognition.onstart = () => {
                    MIC_BUTTON.classList.add('listening');
                    MIC_STATUS.textContent = "Listening...";
                    setStatus("Please say: 'Set a reminder for [task] in 5 minutes'.", false);
                };

                recognition.onresult = (event) => {
                    const transcript = event.results[0][0].transcript;
                    processVoiceCommand(transcript);
                };

                recognition.onend = () => {
                    MIC_BUTTON.classList.remove('listening');
                    MIC_STATUS.textContent = "Click to Speak";
                };

                recognition.onerror = (event) => {
                    MIC_BUTTON.classList.remove('listening');
                    MIC_STATUS.textContent = "Click to Speak";
                    setStatus(`Voice error: ${event.error}. Please try again.`, true);
                };

            } else {
                MIC_BUTTON.disabled = true;
                MIC_STATUS.textContent = "Voice Not Supported";
                setStatus("Speech recognition is not supported in this browser. Please use manual entry.", true);
            }
        };

        /**
         * Processes the transcript from the voice command.
         * @param {string} transcript The recognized speech.
         */
        const processVoiceCommand = (transcript) => {
            const lowerTranscript = transcript.toLowerCase();

            // 1. Main Reminder Pattern (Voice Command)
            const match = lowerTranscript.match(/set a reminder for (.+?) (?:on|in|at) (.+)/);
            
            if (match && match.length === 3) {
                const text = match[1].trim();
                const timePhrase = match[2].trim();
                const time = parseReminderTime(timePhrase); 
                
                if (time) {
                    addReminder(text, time);
                }
                return;
            }

            // 2. Fallback for Unmatched Commands
            setStatus(`I heard "${transcript}" but I couldn't understand that command. Please try "Set a reminder for [task] in 5 seconds."`, true);
        };


        // --- Initialization ---

        window.onload = () => {
            // Attach event listeners
            SET_MANUAL_BTN.onclick = handleManualSet;
            REMINDER_INPUT.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    handleManualSet();
                }
            });

            // Start the main loop to check for due alarms
            setInterval(mainLoop, 1000);

            // Initialize speech services
            if ('speechSynthesis' in window) {
                window.speechSynthesis.getVoices(); 
            }
            setupSpeechRecognition();
            renderReminders(); // Initial empty render
        };

    </script>
</body>
</html>
