<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vocal Reminder App</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            min-height: 100vh;
            background-color: #f7f9fc;
        }
        .mic-button {
            transition: all 0.2s ease;
        }
        .mic-button:hover {
            transform: scale(1.05);
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
        }
        .listening {
            animation: pulse-ring 1.5s infinite;
        }
        @keyframes pulse-ring {
            0% { box-shadow: 0 0 0 0 rgba(76, 29, 149, 0.4); }
            70% { box-shadow: 0 0 0 10px rgba(76, 29, 149, 0); }
            100% { box-shadow: 0 0 0 0 rgba(76, 29, 149, 0); }
        }
        /* Shake animation applied to the inline alert box */
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            10%, 30%, 50%, 70%, 90% { transform: translateX(-10px); }
            20%, 40%, 60%, 80% { transform: translateX(10px); }
        }
        .shake-active {
            animation: shake 0.5s cubic-bezier(.36,.07,.19,.97) both;
        }
        /* Custom scrollbar for reminders list */
        .reminder-list::-webkit-scrollbar {
            width: 6px;
        }
        .reminder-list::-webkit-scrollbar-thumb {
            background-color: #cbd5e1;
            border-radius: 3px;
        }
        .reminder-list::-webkit-scrollbar-track {
            background-color: #f1f5f9;
        }
    </style>
</head>
<body class="p-4 md:p-8">
    <div class="max-w-4xl mx-auto bg-white rounded-xl shadow-2xl p-6 md:p-10 border border-gray-100">

        <h1 class="text-3xl font-bold text-indigo-700 mb-6 text-center">
            Vocal & Manual Reminder App
        </h1>

        <!-- Status and Recognition Area -->
        <div class="flex flex-col items-center mb-8 p-4 bg-indigo-50 rounded-lg shadow-inner">
            <button id="MIC_BTN" class="mic-button w-20 h-20 rounded-full bg-indigo-600 text-white flex items-center justify-center shadow-lg focus:outline-none focus:ring-4 focus:ring-indigo-300">
                <svg id="MIC_ICON" class="w-8 h-8 transition-transform duration-300" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor">
                    <path d="M12 14c1.66 0 3-1.34 3-3V5c0-1.66-1.34-3-3-3S9 3.34 9 5v6c0 1.66 1.34 3 3 3z"/>
                    <path d="M17 11c0 2.76-2.24 5-5 5s-5-2.24-5-5H5c0 3.53 2.61 6.43 6 6.91V21h2v-3.09c3.39-.48 6-3.38 6-6.91h-2z"/>
                </svg>
            </button>
            <p id="STATUS_TEXT" class="mt-4 text-center text-gray-700 font-medium h-12 flex items-center justify-center"></p>
        </div>

        <!-- Manual Input Area -->
        <div class="mb-8">
            <label for="REMINDER_INPUT" class="block text-sm font-medium text-gray-700 mb-2">Set a Reminder or Control Alert (e.g., "snooze for 10 seconds"):</label>
            <div class="flex rounded-md shadow-sm">
                <input type="text" id="REMINDER_INPUT" placeholder="e.g., Pay bills next Tuesday at 9:00 AM" class="flex-grow p-3 border border-gray-300 rounded-l-lg focus:ring-indigo-500 focus:border-indigo-500">
                <button id="SET_MANUAL_BTN" class="px-5 py-3 bg-green-500 text-white rounded-r-lg hover:bg-green-600 transition duration-150 flex items-center justify-center">
                    <!-- Writing/Pencil Icon -->
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="w-6 h-6">
                        <path d="M17 3a2.85 2.85 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5L17 3z"/>
                    </svg>
                </button>
            </div>
        </div>

        <!-- Active Reminder Alert Display (Inline and Non-Blocking) -->
        <div id="ACTIVE_ALERT_DISPLAY" class="hidden mb-8 p-6 bg-red-100 border border-red-400 rounded-xl shadow-lg">
            <h3 class="text-xl font-bold text-red-700 mb-3 flex items-center">
                <svg class="w-5 h-5 mr-2" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor">
                    <path d="M22 5.86l-7.91 7.91c-.4.4-.94.64-1.52.64s-1.12-.24-1.52-.64L2 5.86V20c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V5.86zM4 4h16c.55 0 1 .45 1 1v.79l-9 9-9-9V5c0-.55.45-1 1-1z"/>
                </svg>
                Active Reminder!
            </h3>
            <p id="ALERT_TEXT" class="text-gray-800 text-lg font-medium mb-4"></p>
            <div class="flex justify-end space-x-3">
                <button id="SNOOZE_BTN" data-id="" data-snooze-minutes="5" class="px-4 py-2 text-sm font-semibold rounded-lg bg-yellow-500 text-white hover:bg-yellow-600 transition duration-150 shadow-md">
                    Snooze (5 min)
                </button>
                <button id="DISMISS_BTN" data-id="" class="px-4 py-2 text-sm font-semibold rounded-lg bg-red-500 text-white hover:bg-red-600 transition duration-150 shadow-md">
                    Dismiss
                </button>
            </div>
        </div>


        <!-- Reminder List -->
        <div class="p-6 bg-gray-50 rounded-lg shadow-md">
            <h2 class="text-2xl font-semibold text-gray-800 border-b pb-3 mb-4">Pending Reminders</h2>
            <div id="REMINDERS_LIST" class="reminder-list space-y-3 max-h-80 overflow-y-auto">
                <!-- Reminders will be inserted here -->
            </div>
            <p id="NO_REMINDERS" class="text-center text-gray-500 italic mt-4 hidden">No reminders set yet. Get organized!</p>
        </div>

    </div>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, setDoc, onSnapshot, collection, query, updateDoc, deleteDoc, serverTimestamp, runTransaction } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        import { setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        setLogLevel('Debug'); // Enable for easier debugging of Firestore and speech recognition issues

        // --- Global Firebase & Auth Setup ---
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {};
        
        let db, auth, userId = null;
        let isAuthReady = false;

        const app = initializeApp(firebaseConfig);
        db = getFirestore(app);
        auth = getAuth(app);

        // --- DOM Elements ---
        const MIC_BTN = document.getElementById('MIC_BTN');
        const MIC_ICON = document.getElementById('MIC_ICON');
        const STATUS_TEXT = document.getElementById('STATUS_TEXT');
        const REMINDERS_LIST = document.getElementById('REMINDERS_LIST');
        const NO_REMINDERS = document.getElementById('NO_REMINDERS');
        const REMINDER_INPUT = document.getElementById('REMINDER_INPUT');
        const SET_MANUAL_BTN = document.getElementById('SET_MANUAL_BTN');
        
        // --- Alert Elements (Now inline) ---
        const ACTIVE_ALERT_DISPLAY = document.getElementById('ACTIVE_ALERT_DISPLAY');
        const ALERT_TEXT = document.getElementById('ALERT_TEXT');
        const SNOOZE_BTN = document.getElementById('SNOOZE_BTN');
        const DISMISS_BTN = document.getElementById('DISMISS_BTN');


        // --- Core State and Constants ---
        const REMINDER_COLLECTION = `artifacts/${appId}/users/`;
        let recognition = null;
        let isListening = false;
        let reminders = [];
        const SPEAK_VOICE_NAME = 'Google US English'; // Preferred voice
        let alertsActive = new Set(); // To track which reminders are currently displayed as an alert

        // --- Firebase Initialization and Authentication ---

        onAuthStateChanged(auth, async (user) => {
            if (user) {
                userId = user.uid;
            } else {
                // If token is available, sign in. Otherwise, sign in anonymously.
                try {
                    // Access the global __initial_auth_token directly using a robust existence check.
                    if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                        await signInWithCustomToken(auth, __initial_auth_token);
                        userId = auth.currentUser.uid;
                    } else {
                        await signInAnonymously(auth);
                        userId = auth.currentUser.uid;
                    }
                } catch (error) {
                    console.error("Firebase Auth Error:", error);
                    // Fallback UUID if sign-in fails
                    userId = crypto.randomUUID();
                }
            }
            isAuthReady = true;
            console.log("Auth Ready. User ID:", userId);
            // Once auth is ready, start listening for data
            setupReminderListener();
        });


        // --- Utility Functions ---

        /**
         * Sets the status message on the UI and optionally speaks it.
         * @param {string} message The message to display.
         * @param {boolean} speak If true, the message is read aloud.
         */
        function setStatus(message, speak = false) {
            STATUS_TEXT.textContent = message;
            if (speak && 'speechSynthesis' in window) {
                speakText(message);
            }
        }

        /**
         * Converts a user-friendly time phrase into a JavaScript Date object.
         * Uses simple, rule-based parsing for relative times and "tomorrow at X time".
         * @param {string} timePhrase The time phrase (e.g., "in 30 minutes", "tomorrow at 5pm", "October 25th 11am").
         * @returns {Date|null} The parsed Date object or null if parsing fails or time is in the past.
         */
        function parseReminderTime(timePhrase) {
            let lowerPhrase = timePhrase.toLowerCase().trim();
            const now = new Date();
            let dateToReturn = null;

            // CRITICAL CLEANUP STEP: Remove common transcription noise
            lowerPhrase = lowerPhrase.replace(/\b(?:more|for)\s+/g, '').trim();

            // 1. "in X seconds/minutes/hours/days" OR "X seconds/minutes/hours/days"
            // Handles "in 30 minutes", "30 minutes", "5 seconds", etc.
            const relativeMatch = lowerPhrase.match(/(?:in\s+)?(\d+)\s+(second|minute|hour|day)s?/);
            if (relativeMatch) {
                const amount = parseInt(relativeMatch[1], 10);
                const unit = relativeMatch[2];
                const future = new Date(now);
                if (unit.startsWith('second')) future.setSeconds(now.getSeconds() + amount);
                else if (unit.startsWith('minute')) future.setMinutes(now.getMinutes() + amount);
                else if (unit.startsWith('hour')) future.setHours(now.getHours() + amount);
                else if (unit.startsWith('day')) future.setDate(now.getDate() + amount);
                dateToReturn = future;
            } 
            
            // 2. Handle "tomorrow" with explicit time parsing
            if (!dateToReturn && lowerPhrase.includes('tomorrow')) {
                const tomorrow = new Date(now);
                tomorrow.setDate(now.getDate() + 1); // Set to start of tomorrow (00:00:00)
                
                // Regex to capture time in the phrase (e.g., "at 9am", "9:30", "10 p.m.")
                // Captures H:MM or H and optional AM/PM
                const timeRegex = /(?:at\s*)?(\d{1,2}(?::\d{2})?)\s*(a\.?m\.?|p\.?m\.?)?/i;
                const timeMatch = lowerPhrase.match(timeRegex);

                if (timeMatch) {
                    let [ , hourStr, ampm] = timeMatch;
                    let hour = parseInt(hourStr.split(':')[0], 10);
                    let minute = hourStr.includes(':') ? parseInt(hourStr.split(':')[1], 10) : 0;
                    
                    if (ampm) {
                         const lowerAmpm = ampm.toLowerCase();
                         if (lowerAmpm.startsWith('p') && hour < 12) {
                             hour += 12;
                         } else if (lowerAmpm.startsWith('a') && hour === 12) {
                             hour = 0; // 12 AM is midnight
                         }
                    } 
                    // Note: If no AM/PM, it defaults to 24-hour time (e.g., 9 means 9 AM, 15 means 3 PM)

                    tomorrow.setHours(hour, minute, 0, 0);
                    dateToReturn = tomorrow;

                } else {
                    // If "tomorrow" is present but no time is specified, default to 9 AM
                    tomorrow.setHours(9, 0, 0, 0); 
                    dateToReturn = tomorrow;
                }
            }


            // 3. Fallback for Specific Dates (Oct 25th 11am) using the browser's native parser
            if (!dateToReturn) {
                 const date = new Date(lowerPhrase);
                 if (!isNaN(date.getTime())) {
                    dateToReturn = date;
                 }
            }


            // Final check: Is the calculated time in the future?
            if (dateToReturn && dateToReturn.getTime() > now.getTime() - (60 * 1000)) { // Allow 1 minute grace
                return dateToReturn;
            }
            
            return null; // Past time or invalid format
        }

        // --- Speech Functions ---

        /**
         * Reads a message using the Web Speech API.
         * @param {string} text The text to speak.
         */
        function speakText(text) {
            if (!'speechSynthesis' in window) return;

            const utterance = new SpeechSynthesisUtterance(text);
            const voices = window.speechSynthesis.getVoices();
            const preferredVoice = voices.find(v => v.name === SPEAK_VOICE_NAME) || voices[0];
            
            utterance.voice = preferredVoice;
            utterance.rate = 1.0;
            utterance.pitch = 1.0;
            window.speechSynthesis.speak(utterance);
        }

        // --- Reminder Data Management ---

        /**
         * Adds a new reminder to Firestore.
         * @param {string} text The reminder description.
         * @param {Date} time The target Date object for the reminder.
         */
        async function addReminder(text, time) {
            if (!isAuthReady || !userId) {
                setStatus("System loading... please wait for authentication.", true);
                return;
            }

            if (!text || !time || isNaN(time.getTime()) || time.getTime() < Date.now()) {
                setStatus("Error: Invalid task or time. Please ensure the time is in the future. (Did you include a time with 'tomorrow'?)", true);
                return;
            }

            const reminderData = {
                text: text,
                targetTime: time.getTime(), // Store as milliseconds
                createdAt: serverTimestamp(),
                isDone: false
            };

            try {
                const colRef = collection(db, `${REMINDER_COLLECTION}${userId}/reminders`);
                await runTransaction(db, async (transaction) => {
                    // Using setDoc with an auto-generated ID (doc(colRef))
                    await transaction.set(doc(colRef), reminderData);
                });
                setStatus(`Reminder set for: ${new Date(time).toLocaleString()}. Task: ${text}`, true);
                REMINDER_INPUT.value = '';
            } catch (e) {
                console.error("Error adding document: ", e);
                setStatus("Error saving reminder. Check console.", true);
            }
        }
        
        /**
         * Deletes a reminder from Firestore.
         * @param {string} id The document ID of the reminder.
         */
        async function deleteReminder(id) {
            if (!isAuthReady || !userId) return;

            try {
                const docRef = doc(db, `${REMINDER_COLLECTION}${userId}/reminders`, id);
                await deleteDoc(docRef);
                // If the deleted reminder was the active alert, hide the alert UI
                if (alertsActive.has(id)) {
                    hideAlert();
                }
            } catch (e) {
                console.error("Error removing document: ", e);
                setStatus("Error deleting reminder.", false);
            }
        }

        /**
         * Snoozes a reminder by updating its target time in Firestore.
         * UPDATED: Takes msDuration for flexible snooze times (seconds/minutes).
         * @param {string} id The document ID of the reminder.
         * @param {number} msDuration The duration to snooze in milliseconds.
         * @param {string} displayMessage The message to use for the status text (e.g., '10 seconds').
         */
        async function snoozeReminder(id, msDuration, displayMessage) {
            if (!isAuthReady || !userId) return;

            try {
                const docRef = doc(db, `${REMINDER_COLLECTION}${userId}/reminders`, id);
                const newTargetTime = Date.now() + msDuration;
                await updateDoc(docRef, {
                    targetTime: newTargetTime
                });
                hideAlert();
                setStatus(`Reminder snoozed! Will alert again in ${displayMessage}.`, true);
            } catch (e) {
                console.error("Error snoozing reminder: ", e);
            }
        }

        /**
         * Sets up the real-time listener for reminders from Firestore.
         */
        function setupReminderListener() {
            if (!isAuthReady || !userId) return;
            
            // Note: We avoid orderBy() to prevent needing Firestore indexes, and sort locally instead.
            const q = query(collection(db, `${REMINDER_COLLECTION}${userId}/reminders`));
            
            onSnapshot(q, (snapshot) => {
                reminders = snapshot.docs.map(doc => ({
                    id: doc.id,
                    ...doc.data()
                }))
                .filter(r => !r.isDone)
                // Local sort by targetTime (asc)
                .sort((a, b) => a.targetTime - b.targetTime); 

                renderReminders();
            }, (error) => {
                console.error("Error listening to reminders: ", error);
            });
        }

        // --- Alert Functions (Now INLINE) ---

        /**
         * Hides the reminder alert UI.
         */
        function hideAlert() {
            ACTIVE_ALERT_DISPLAY.classList.add('hidden');
            ACTIVE_ALERT_DISPLAY.classList.remove('shake-active'); // Remove shake class
            alertsActive.clear(); 
        }

        /**
         * Shows the inline reminder alert UI.
         * @param {object} reminder The triggered reminder object.
         */
        function showReminderAlert(reminder) {
            // Only show one alert at a time
            if (alertsActive.has(reminder.id)) return; 
            
            // Add the ID to the active set
            alertsActive.add(reminder.id);

            ALERT_TEXT.textContent = reminder.text;
            
            // Set data-id on buttons for handling
            SNOOZE_BTN.setAttribute('data-id', reminder.id);
            DISMISS_BTN.setAttribute('data-id', reminder.id);

            // Show the inline alert and add shake effect
            ACTIVE_ALERT_DISPLAY.classList.remove('hidden');
            ACTIVE_ALERT_DISPLAY.classList.add('shake-active'); 
            
            speakText(`Reminder: ${reminder.text}`);
            setStatus(`ALERT: Time to ${reminder.text}! Please dismiss or snooze.`, true);
        }

        // --- UI Rendering ---

        /**
         * Renders the current list of reminders to the DOM.
         */
        function renderReminders() {
            REMINDERS_LIST.innerHTML = '';
            if (reminders.length === 0) {
                NO_REMINDERS.classList.remove('hidden');
                return;
            }
            NO_REMINDERS.classList.add('hidden');

            reminders.forEach(reminder => {
                const targetDate = new Date(reminder.targetTime);
                const timeRemaining = reminder.targetTime - Date.now();
                const minutes = Math.floor(timeRemaining / 60000);
                const seconds = Math.floor((timeRemaining % 60000) / 1000);

                let timeLeftText = "Due now";
                if (minutes > 0) {
                    timeLeftText = `in ${minutes} min`;
                } else if (seconds > 0) {
                    timeLeftText = `in ${seconds} sec`;
                } else if (timeRemaining < 0) {
                    timeLeftText = "OVERDUE";
                }

                const reminderElement = document.createElement('div');
                // Use a different color if it's currently alerting
                const isAlertingClass = alertsActive.has(reminder.id) ? 'bg-red-200 border-l-4 border-red-600' : 
                                       (timeRemaining <= 0 ? 'bg-red-100 border-l-4 border-red-500' : 'bg-white border-l-4 border-indigo-400 hover:shadow-lg');

                reminderElement.className = `p-4 flex justify-between items-center rounded-lg shadow transition duration-150 ${isAlertingClass}`;
                
                reminderElement.innerHTML = `
                    <div class="flex-1 min-w-0">
                        <p class="text-lg font-semibold text-gray-800 break-words">${reminder.text}</p>
                        <p class="text-sm text-gray-500 mt-1">
                            Scheduled: ${targetDate.toLocaleString()}
                        </p>
                    </div>
                    <div class="flex flex-col items-end ml-4">
                        <span class="text-sm font-bold ${timeRemaining <= 0 ? 'text-red-600' : 'text-indigo-600'} mb-2">${timeLeftText}</span>
                        <button data-id="${reminder.id}" class="delete-btn text-xs font-medium text-red-500 hover:text-red-700 p-1 rounded-full hover:bg-red-50 transition duration-150">
                            Remove
                        </button>
                    </div>
                `;
                
                REMINDERS_LIST.appendChild(reminderElement);
            });

            // Attach event listeners to new delete buttons
            document.querySelectorAll('.delete-btn').forEach(btn => {
                btn.onclick = (e) => {
                    const id = e.target.getAttribute('data-id');
                    deleteReminder(id);
                };
            });
        }

        // --- Main Loop and Alerting ---

        function mainLoop() {
            const now = Date.now();
            
            reminders.forEach(reminder => {
                // Only trigger alert if the time has passed and it's NOT already in the active alerts set
                if (reminder.targetTime <= now && !alertsActive.has(reminder.id)) {
                    showReminderAlert(reminder);
                }
            });

            // Re-render to update 'time left' labels
            renderReminders();
        }

        // --- Core Alert Command Handling ---

        /**
         * Handles snooze/dismiss commands when an alert is currently showing.
         * @param {string} commandText The recognized or manual command text.
         * @returns {boolean} True if a command was handled, false otherwise.
         */
        function handleActiveAlertCommand(commandText) {
            if (alertsActive.size === 0) return false;

            // Get the ID of the currently active alert (we only show one at a time)
            const activeId = alertsActive.keys().next().value;
            let lowerCommand = commandText.toLowerCase().trim();

            // 1. Dismiss Command
            if (lowerCommand.includes('dismiss') || lowerCommand.includes('cancel') || lowerCommand.includes('stop')) {
                deleteReminder(activeId); 
                hideAlert();
                setStatus("Reminder dismissed.", true);
                return true;
            }

            // 2. Snooze Command (Aggressive Parsing)
            if (lowerCommand.includes('snooze')) {
                // Apply the cleanup specifically for the snooze command to handle "snooze for 5 more seconds"
                let snoozeCommand = lowerCommand.replace(/\b(?:more|for)\s+/g, ' '); 
                
                const snoozeMatch = snoozeCommand.match(/snooze.*?(\d+)\s*(second|minute)s?/);
                
                if (snoozeMatch) {
                    const amount = parseInt(snoozeMatch[1], 10);
                    const unit = snoozeMatch[2];
                    let msDuration;
                    let displayMsg;
                    
                    if (unit.startsWith('second')) {
                        msDuration = amount * 1000;
                        displayMsg = `${amount} seconds`;
                    } else if (unit.startsWith('minute')) {
                        msDuration = amount * 60 * 1000;
                        displayMsg = `${amount} minutes`;
                    }
                    
                    // Safety: ensure a minimum duration of 1 second if amount was parsed as 0
                    if (msDuration === 0) {
                        msDuration = 1000; 
                        displayMsg = '1 second';
                    }

                    snoozeReminder(activeId, msDuration, displayMsg); 
                    return true;
                }
                
                // 3. Simple snooze (default 5 minutes) if a number/unit wasn't found
                if (!snoozeMatch) {
                    const defaultDurationMs = 5 * 60 * 1000;
                    snoozeReminder(activeId, defaultDurationMs, '5 minutes');
                    return true;
                }
            }

            return false;
        }


        // --- Event Handlers ---

        function setupSpeechRecognition() {
            if (!('webkitSpeechRecognition' in window)) {
                setStatus("Speech recognition is not supported in this browser.", false);
                MIC_BTN.disabled = true;
                MIC_BTN.classList.replace('bg-indigo-600', 'bg-gray-400');
                return;
            }

            recognition = new webkitSpeechRecognition();
            recognition.continuous = false; // Stop after a single utterance
            recognition.interimResults = false;
            recognition.lang = 'en-US';

            recognition.onresult = (event) => {
                const transcript = event.results[0][0].transcript;
                handleVoiceCommand(transcript);
            };

            recognition.onerror = (event) => {
                console.error('Speech Recognition Error:', event.error);
                setStatus(`Voice command error: ${event.error}`, true);
                stopListening();
            };

            recognition.onend = () => {
                stopListening();
            };

            MIC_BTN.onclick = () => {
                if (isListening) {
                    recognition.stop();
                } else {
                    startListening();
                }
            };
        }

        function startListening() {
            try {
                recognition.start();
                isListening = true;
                MIC_BTN.classList.add('listening', 'bg-red-500');
                MIC_BTN.classList.remove('bg-indigo-600');
                MIC_ICON.classList.add('animate-ping');
                setStatus("Listening... Say a command like, 'Remind me to change water in 30 minutes.'");
            } catch (e) {
                // Ignore potential 'already started' error
                if (e.name !== 'InvalidStateError') {
                    console.error(e);
                }
            }
        }

        function stopListening() {
            isListening = false;
            MIC_BTN.classList.remove('listening', 'bg-red-500');
            MIC_BTN.classList.add('bg-indigo-600');
            MIC_ICON.classList.remove('animate-ping');
        }

        /**
         * Processes the voice command transcript.
         * @param {string} transcript The recognized text.
         */
        function handleVoiceCommand(transcript) {
            let lowerTranscript = transcript.toLowerCase();
            setStatus(`Heard: "${transcript}"`);
            
            // --- PRE-PROCESSING FIX: Handle Voice Command Duplication ---
            lowerTranscript = lowerTranscript.replace('set a reminder for remind me to', 'remind me to');

            // 1. --- HIGHEST PRIORITY: ACTIVE ALERT CONTROL ---
            if (handleActiveAlertCommand(lowerTranscript)) {
                return;
            }

            // 2. --- NEW REMINDER COMMAND (ROBUST PARSING) ---
            const prefixRegex = /(?:set a reminder for|remind me to)\s+(.+)/;
            const prefixMatch = lowerTranscript.match(prefixRegex);

            if (prefixMatch) {
                let fullText = prefixMatch[1].trim(); 
                let timePhrase = '';
                let taskText = fullText;

                // Attempt to find the time phrase aggressively, prioritizing common time patterns at the tail.
                const timeExtractorRegex = /(?:on|in|at|after)?\s*(\d+\s*(?:second|minute|hour|day)s?|tomorrow.*|next\s+.*|.+at\s+.*)$/i;

                const timeTailMatch = fullText.match(timeExtractorRegex);

                if (timeTailMatch) {
                    timePhrase = timeTailMatch[0].trim();
                    taskText = fullText.substring(0, fullText.length - timeTailMatch[0].length).trim();
                    taskText = taskText.replace(/\s+(?:for|more|on|in|at|after)$/i, '').trim();

                    if (!taskText) taskText = "Reminder";
                } 
                
                if (timePhrase) {
                    const time = parseReminderTime(timePhrase);
                    
                    if (time) {
                        addReminder(taskText, time);
                        return; // Successfully set reminder, EXIT
                    }
                }

                setStatus(`I heard a reminder command, but I couldn't understand the time in "${fullText}". Please try using standard time phrases.`, true);
                return;
            }
            
            // 3. --- FALLBACK: CONTROL COMMAND MISCLASSIFICATION CHECK ---
            // This is ONLY reached if the command did NOT start with a 'set a reminder' prefix AND an alert is not ringing.
            if (lowerTranscript.includes('snooze') || lowerTranscript.includes('dismiss') || lowerTranscript.includes('cancel alert')) {
                setStatus(`I heard a control command ("${transcript}"), but there is no active alert to snooze or dismiss. Please set a reminder first!`, true);
                return;
            }

            // 4. Fallback for Unmatched Commands
            setStatus(`I heard "${transcript}" but I couldn't understand that command. Please try "Set a reminder for [task] on October 25 at 11am." or "Remind me to feed the dog in 2 hours."`, true);
        }

        function handleManualSet() {
            const fullCommand = REMINDER_INPUT.value.trim();
            if (!fullCommand) {
                setStatus("Please enter a reminder command.", false);
                return;
            }
            
            // Manually trigger the voice command handler for consistency
            handleVoiceCommand(`set a reminder for ${fullCommand}`);
        }

        // --- Initialization ---

        window.onload = () => {
            SET_MANUAL_BTN.onclick = handleManualSet;
            REMINDER_INPUT.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    handleManualSet();
                }
            });

            // CRITICAL: These listeners ensure the inline alert buttons work
            SNOOZE_BTN.onclick = (e) => {
                const id = e.target.getAttribute('data-id');
                const minutes = parseInt(e.target.getAttribute('data-snooze-minutes'), 10);
                const msDuration = minutes * 60 * 1000;
                snoozeReminder(id, msDuration, `${minutes} minutes`); 
            };

            DISMISS_BTN.onclick = (e) => {
                const id = e.target.getAttribute('data-id');
                deleteReminder(id); 
                hideAlert();
            };

            setInterval(mainLoop, 1000); 

            if ('speechSynthesis' in window) {
                // Pre-load voices
                window.speechSynthesis.getVoices();
            }
            setupSpeechRecognition();
            setStatus("Welcome! Click the microphone or type below to set reminders, including specific dates.");
            // setupReminderListener is called after auth is ready
        };
    </script>
</body>
</html>
