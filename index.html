<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vocal Reminder App</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <!-- Font Awesome for icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            min-height: 100vh;
            background-color: #f7f9fc;
        }
        .mic-button {
            transition: all 0.2s ease;
        }
        .mic-button:hover {
            transform: scale(1.05);
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
        }
        .listening {
            animation: pulse-ring 1.5s infinite;
        }
        @keyframes pulse-ring {
            0% { box-shadow: 0 0 0 0 rgba(76, 29, 149, 0.4); }
            70% { box-shadow: 0 0 0 10px rgba(76, 29, 149, 0); }
            100% { box-shadow: 0 0 0 0 rgba(76, 29, 149, 0); }
        }
        .pen-button {
            transition: transform 0.1s ease;
        }
        .pen-button:active {
            transform: scale(0.95);
        }
        /* Custom style for the due reminder */
        .reminder-due {
            background-color: #fef2f2; /* Red-50 */
            border-left: 4px solid #ef4444; /* Red-500 */
        }
    </style>
</head>
<body class="p-4 sm:p-8 flex flex-col items-center">

    <!-- Main Container -->
    <div class="w-full max-w-xl">

        <h1 class="text-3xl font-bold text-gray-800 text-center mb-6">Vocal Reminder</h1>
        
        <!-- Status Message Area -->
        <div id="status-message" class="p-3 text-sm text-center rounded-lg mb-6 transition-all duration-300 min-h-[40px] flex items-center justify-center bg-blue-100 text-blue-800 border border-blue-200">
            Reminder app running. Reminders are saved for this session only.
        </div>

        <!-- Microphone Input Area -->
        <div class="flex flex-col items-center space-y-4 mb-8">
            <button id="mic-button" class="mic-button w-24 h-24 rounded-full bg-indigo-600 text-white flex items-center justify-center shadow-lg transition duration-150 ease-in-out">
                <i class="fas fa-microphone text-3xl"></i>
            </button>
            <p id="mic-status" class="text-sm text-gray-500 font-medium">Click to Speak</p>
        </div>

        <!-- Manual Text Input -->
        <div class="text-input-group flex space-x-2">
            <input type="text" id="reminder-input" placeholder='e.g., "Drink water in 5 seconds"' class="flex-grow p-3 border border-gray-300 rounded-lg focus:ring-indigo-500 focus:border-indigo-500 shadow-sm transition duration-150 ease-in-out" />
            <button id="set-manual-btn" class="pen-button p-3 bg-white text-indigo-600 border border-gray-300 rounded-lg shadow-sm hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-indigo-500">
                <i class="fas fa-pen text-xl"></i>
            </button>
        </div>
        <p class="text-xs text-gray-400 mt-2 text-center">Use format: [Task] [on/in/at] [Time Phrase]</p>

        <hr class="my-8 border-gray-200">

        <!-- Reminder List -->
        <h2 class="text-2xl font-semibold text-gray-800 mb-4">Upcoming Reminders</h2>
        <div id="reminders-list" class="space-y-3">
            <!-- Reminders will be injected here -->
            <p id="no-reminders" class="text-center text-gray-500 p-4 bg-white rounded-lg shadow-md">No reminders set yet.</p>
        </div>
    </div>

    <script>
        // --- GLOBAL SETUP (NO STORAGE, NO MODAL) ---
        let reminders = []; // Session-only array
        let recognition = null; 
        let triggeredReminders = new Set(); // Tracks reminders that have been announced via TTS

        // --- DOM Elements ---
        const STATUS_MESSAGE = document.getElementById('status-message');
        const REMINDERS_LIST = document.getElementById('reminders-list');
        const REMINDER_INPUT = document.getElementById('reminder-input');
        const SET_MANUAL_BTN = document.getElementById('set-manual-btn');
        const MIC_BUTTON = document.getElementById('mic-button');
        const MIC_STATUS = document.getElementById('mic-status');

        // --- Utility Functions ---

        /**
         * Formats the remaining time into a human-readable countdown string.
         * @param {number} targetTimestamp The future timestamp in milliseconds.
         * @returns {string} Formatted time string (e.g., "2d 5h 10m")
         */
        const formatTimeRemaining = (targetTimestamp) => {
            const remainingMs = targetTimestamp - Date.now();
            if (remainingMs <= 0) return "Due Now!";

            const totalSeconds = Math.floor(remainingMs / 1000);
            const days = Math.floor(totalSeconds / (3600 * 24));
            const hours = Math.floor((totalSeconds % (3600 * 24)) / 3600);
            const minutes = Math.floor((totalSeconds % 3600) / 60);
            const seconds = totalSeconds % 60;

            const parts = [];
            if (days > 0) parts.push(`${days}d`);
            if (hours > 0) parts.push(`${hours}h`);
            if (minutes > 0) parts.push(`${minutes}m`);
            if (totalSeconds < 60 && totalSeconds > 0) {
                 // Always show seconds if the countdown is less than a minute
                parts.push(`${seconds}s`);
            } else if (totalSeconds === 0) {
                return "Due Now!";
            }
            
            // Only show up to 3 biggest units, ensuring at least one is shown if time is > 0
            if (parts.length === 0 && totalSeconds > 0) {
                 return `${seconds}s`;
            }

            return parts.slice(0, 3).join(' ');
        };

        /**
         * Displays a status message to the user.
         * @param {string} message The message to display.
         * @param {boolean} isError If true, displays as an error.
         */
        const setStatus = (message, isError) => {
            STATUS_MESSAGE.textContent = message;
            STATUS_MESSAGE.className = 'p-3 text-sm text-center rounded-lg mb-6 transition-all duration-300 min-h-[40px] flex items-center justify-center';
            if (isError) {
                STATUS_MESSAGE.classList.add('bg-red-100', 'text-red-800', 'border', 'border-red-200');
            } else {
                STATUS_MESSAGE.classList.add('bg-blue-100', 'text-blue-800', 'border', 'border-blue-200');
            }
        };

        // --- Reminder Management (Session Only) ---

        /**
         * Adds a new reminder to the local array and triggers a UI update.
         */
        const addReminder = (text, timestamp) => {
            const newId = Date.now().toString() + Math.random().toString(36).substring(2, 9);
            reminders.push({
                id: newId,
                text: text,
                timestamp: timestamp,
                createdAt: Date.now()
            });
            reminders.sort((a, b) => a.timestamp - b.timestamp);
            renderReminders();
            setStatus(`Reminder set! It will go off in: ${formatTimeRemaining(timestamp)}`, false);
        };

        /**
         * Deletes a reminder from the local array and triggers a UI update.
         */
        const deleteReminder = (id) => {
            reminders = reminders.filter(r => r.id !== id);
            triggeredReminders.delete(id); 
            renderReminders();
        };

        // --- Core Logic: Time Parsing ---

        /**
         * Parses a natural language time phrase into a future UTC timestamp.
         */
        const parseReminderTime = (phrase) => {
            const lowerPhrase = phrase.toLowerCase().trim();
            const now = new Date();
            let targetTime = null;

            // 1. Relative Time Parsing (e.g., "5 seconds", "2 hours")
            const relativeMatch = lowerPhrase.match(/(\d+)\s+(second|minute|hour|day|week)s?/i);

            if (relativeMatch) {
                const value = parseInt(relativeMatch[1], 10);
                const unit = relativeMatch[2];
                targetTime = new Date(now.getTime());

                switch (unit) {
                    case 'second':
                        targetTime.setSeconds(now.getSeconds() + value);
                        break;
                    case 'minute':
                        targetTime.setMinutes(now.getMinutes() + value);
                        break;
                    case 'hour':
                        targetTime.setHours(now.getHours() + value);
                        break;
                    case 'day':
                        targetTime.setDate(now.getDate() + value);
                        break;
                    case 'week':
                        targetTime.setDate(now.getDate() + (value * 7));
                        break;
                }
                
                if (targetTime.getTime() > now.getTime()) {
                    return targetTime.getTime();
                }
            }

            // 2. Specific Time/Date Parsing (e.g., "tomorrow at 5pm", "4:30 PM")
            try {
                let parsedDate = new Date(phrase);
                
                if (!isNaN(parsedDate.getTime())) {
                    if (parsedDate.getTime() <= now.getTime()) {
                        // If only a time was specified (e.g., "5 PM"), set it for tomorrow.
                        // We check if the parsed date is the same day but the time is past.
                        const timeOnly = parsedDate.toDateString() === now.toDateString() && parsedDate.getTime() < now.getTime();
                        if (timeOnly) {
                            parsedDate.setDate(parsedDate.getDate() + 1);
                        } else {
                            return null; // Date was in the past and was not just a time
                        }
                    }
                    targetTime = parsedDate;
                }
            } catch (e) {
                // Ignore date parsing errors
            }

            if (targetTime && targetTime.getTime() > now.getTime()) {
                return targetTime.getTime();
            }

            setStatus(`Couldn't understand the time phrase "${phrase}". Please use relative time (e.g., '5 minutes') or specific time (e.g., '4 PM').`, true);
            return null;
        };

        // --- UI Rendering ---

        /**
         * Renders the current list of reminders to the DOM.
         */
        const renderReminders = () => {
            REMINDERS_LIST.innerHTML = '';
            
            if (reminders.length === 0) {
                REMINDERS_LIST.innerHTML = '<p id="no-reminders" class="text-center text-gray-500 p-4 bg-white rounded-lg shadow-md">No reminders set yet.</p>';
                return;
            }

            reminders.forEach(r => {
                const isDue = triggeredReminders.has(r.id);
                
                const reminderElement = document.createElement('div');
                
                reminderElement.className = `p-4 flex items-center justify-between rounded-lg shadow-md transition duration-150 
                    ${isDue ? 'reminder-due hover:shadow-xl' : 'bg-white hover:shadow-lg'}`;
                    
                // Use data-timestamp for the countdown update function
                reminderElement.innerHTML = `
                    <div>
                        <p class="font-medium ${isDue ? 'text-red-800 font-bold' : 'text-gray-800'} break-words">${r.text}</p>
                        <p class="text-sm ${isDue ? 'text-red-600 font-bold' : 'text-indigo-500'} mt-1 countdown-display" 
                           data-timestamp="${r.timestamp}" 
                           data-id="${r.id}">
                            ${isDue ? 'DUE NOW!' : formatTimeRemaining(r.timestamp)}
                        </p>
                    </div>
                    <button data-id="${r.id}" class="delete-btn text-gray-400 hover:text-red-600 ml-4 p-2 transition duration-150">
                        <i class="fas fa-trash-alt"></i>
                    </button>
                `;
                REMINDERS_LIST.appendChild(reminderElement);
            });

            // Attach delete listeners
            document.querySelectorAll('.delete-btn').forEach(button => {
                button.onclick = (e) => {
                    const id = e.currentTarget.getAttribute('data-id');
                    deleteReminder(id);
                    setStatus("Reminder deleted.", false);
                };
            });
        };
        
        // --- Countdown Update Loop ---

        /**
         * Updates the text content of all visible countdown timers.
         * Runs every 500ms for a smooth update.
         */
        const updateCountdown = () => {
            document.querySelectorAll('.countdown-display').forEach(el => {
                const timestamp = parseInt(el.getAttribute('data-timestamp'));
                const id = el.getAttribute('data-id');
                const isDue = triggeredReminders.has(id);

                if (isDue) {
                    el.textContent = 'DUE NOW!';
                } else if (timestamp > Date.now()) {
                    // Update countdown for future reminders
                    el.textContent = formatTimeRemaining(timestamp);
                }
            });
        };

        // --- Main Loop (Checking Alarms for TTS and Visual Alert) ---

        const mainLoop = () => {
            const now = Date.now();
            reminders.forEach(r => {
                if (r.timestamp < now && !triggeredReminders.has(r.id)) {
                    // New, due reminder found!
                    triggeredReminders.add(r.id);
                    
                    setStatus(`ALERT: "${r.text}" is DUE NOW! Please delete it from the list.`, true);

                    // Announce it via TTS once (no modal)
                    if ('speechSynthesis' in window) {
                        window.speechSynthesis.cancel();
                        let utterance = new SpeechSynthesisUtterance(`Reminder: ${r.text}`);
                        window.speechSynthesis.speak(utterance);
                    }
                    
                    // Re-render to apply the red "DUE NOW" style
                    renderReminders(); 
                }
            });
        };

        // --- Input Handling ---

        /**
         * Handles manual text input submission.
         */
        const handleManualSet = () => {
            const inputContent = REMINDER_INPUT.value.trim();
            if (!inputContent) { return; }

            // Regex to find: [task] (on/in/at) [time phrase]
            // (.+?) : Non-greedy match for the task
            // \s+ : one or more spaces
            // (?:on|in|at) : Non-capturing group for the keywords
            // (.+) : The time phrase
            const match = inputContent.match(/(.+?)\s+(?:on|in|at)\s+(.+)/i);

            if (match && match.length === 3) {
                const text = match[1].trim();
                const timePhrase = match[2].trim();
                
                const time = parseReminderTime(timePhrase);
                
                if (time) {
                    addReminder(text, time);
                    REMINDER_INPUT.value = ''; // Clear only on successful addition
                }
            } else {
                setStatus("Input format error. Please use: [Task] [on/in/at] [Time Phrase]", true);
            }
        };

        // --- Speech Recognition ---

        const setupSpeechRecognition = () => {
            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;

            if (SpeechRecognition) {
                recognition = new SpeechRecognition();
                recognition.continuous = false;
                recognition.lang = 'en-US';
                recognition.interimResults = false;
                recognition.maxAlternatives = 1;

                MIC_BUTTON.onclick = () => {
                    try {
                        recognition.start();
                    } catch (e) {
                        console.warn("Speech recognition already running or error starting:", e);
                    }
                };

                recognition.onstart = () => {
                    MIC_BUTTON.classList.add('listening');
                    MIC_STATUS.textContent = "Listening...";
                    setStatus("Say: 'Set a reminder for [task] in 5 minutes'.", false);
                };

                recognition.onresult = (event) => {
                    const transcript = event.results[0][0].transcript;
                    processVoiceCommand(transcript);
                };

                recognition.onend = () => {
                    MIC_BUTTON.classList.remove('listening');
                    MIC_STATUS.textContent = "Click to Speak";
                };

                recognition.onerror = (event) => {
                    MIC_BUTTON.classList.remove('listening');
                    MIC_STATUS.textContent = "Click to Speak";
                    setStatus(`Voice error: ${event.error}. Please try again.`, true);
                };

            } else {
                MIC_BUTTON.disabled = true;
                MIC_STATUS.textContent = "Voice Not Supported";
                setStatus("Speech recognition is not supported in this browser. Please use manual entry.", true);
            }
        };

        /**
         * Processes the transcript from the voice command.
         */
        const processVoiceCommand = (transcript) => {
            const lowerTranscript = transcript.toLowerCase();

            // Main Reminder Pattern (Voice Command)
            const match = lowerTranscript.match(/set a reminder for (.+?) (?:on|in|at) (.+)/);
            
            if (match && match.length === 3) {
                const text = match[1].trim();
                const timePhrase = match[2].trim();
                const time = parseReminderTime(timePhrase); 
                
                if (time) {
                    addReminder(text, time);
                }
                return;
            }

            // Fallback for Unmatched Commands
            setStatus(`I heard "${transcript}" but I couldn't understand the time. Please try "Set a reminder for [task] in 5 seconds."`, true);
        };


        // --- Initialization ---

        window.onload = () => {
            // Attach event listeners
            SET_MANUAL_BTN.onclick = handleManualSet;
            REMINDER_INPUT.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    handleManualSet();
                }
            });

            // Main logic loop (checking for triggered alarms) runs every second
            setInterval(mainLoop, 1000);

            // Countdown display loop runs every half-second for smooth update
            setInterval(updateCountdown, 500); 

            // Initialize speech services
            if ('speechSynthesis' in window) {
                window.speechSynthesis.getVoices(); 
            }
            setupSpeechRecognition();
            renderReminders(); // Initial empty render
        };

    </script>
</body>
</html>
