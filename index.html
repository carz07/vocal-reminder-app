<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Natural Language Reminder App</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f7f9fb;
        }
        .container-card {
            max-width: 500px;
            margin: 2rem auto;
            padding: 1.5rem;
            background: white;
            border-radius: 1rem;
            box-shadow: 0 10px 25px -5px rgba(0, 0, 0, 0.1), 0 0 10px -5px rgba(0, 0, 0, 0.04);
            transition: all 0.3s ease;
        }
        .input-group {
            display: flex;
            gap: 0.5rem;
        }
        .input-field {
            flex-grow: 1;
            padding: 0.75rem 1rem;
            border: 2px solid #e5e7eb;
            border-radius: 0.75rem;
            transition: border-color 0.2s;
        }
        .input-field:focus {
            outline: none;
            border-color: #4f46e5;
        }
        .send-button {
            background-color: #4f46e5;
            color: white;
            border-radius: 0.75rem;
            padding: 0.75rem;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background-color 0.2s, transform 0.1s;
        }
        .send-button:hover {
            background-color: #4338ca;
        }
        .send-button:active {
            transform: scale(0.98);
        }
        .reminder-item {
            background-color: #f3f4f6;
            border-left: 5px solid #4f46e5;
            transition: all 0.2s ease-in-out;
        }
        .reminder-alerting {
            background-color: #fee2e2;
            border-left-color: #ef4444;
            animation: pulse-ring 1s infinite;
        }
        @keyframes pulse-ring {
            0%, 100% {
                box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.4);
            }
            50% {
                box-shadow: 0 0 0 10px rgba(239, 68, 68, 0);
            }
        }
        .log-box {
            background-color: #1f2937;
            color: #d1d5db;
            font-family: monospace;
            white-space: pre-wrap;
            word-break: break-all;
            border-radius: 0.5rem;
        }
        /* Custom SVG for the Pen Icon */
        .pen-icon {
            width: 24px;
            height: 24px;
        }
    </style>
</head>
<body class="p-4">

    <div class="container-card">
        <h1 class="text-3xl font-extrabold text-gray-900 mb-2">Natural Language Reminders</h1>
        <p class="text-gray-500 mb-6">Type commands to set, snooze, dismiss, or delete tasks.</p>

        <div class="mb-6">
            <h2 class="text-lg font-semibold text-gray-800 mb-2">Commands:</h2>
            <ul class="text-sm text-gray-600 space-y-1 ml-4 list-disc">
                <li>**Set**: `[Task]` **on/in/at** `[Time Phrase]` (e.g., `check email in 5m`)</li>
                <li>**Snooze (when alerting)**: `snooze` or `snooze for 5 minutes`</li>
                <li>**Dismiss (when alerting)**: `dismiss`</li>
                <li>**Delete (when alerting)**: `delete`</li>
            </ul>
        </div>

        <div class="input-group mb-4">
            <input type="text" id="commandInput" class="input-field" placeholder="e.g., remind me to drink water in 10s">
            <button id="sendButton" class="send-button">
                <svg class="pen-icon" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15.232 5.232l3.536 3.536m-2.036-5.036a2.5 2.5 0 113.536 3.536L6.5 21.036H3v-3.572L16.732 3.732z"></path>
                </svg>
            </button>
        </div>

        <div id="outputLog" class="log-box p-3 mb-6 h-32 overflow-y-auto text-xs">
            System ready. Type a command to begin.
        </div>

        <h2 class="text-xl font-bold text-gray-900 mb-3">Active Reminders (<span id="reminderCount">0</span>)</h2>
        <div id="reminderListContainer" class="space-y-3">
            <!-- Reminder items will be injected here -->
        </div>
    </div>

    <script>
        // --- Core Setup ---
        let reminderList = [];
        let reminderIdCounter = 1;
        
        // --- Utility Functions ---

        // Simple ID generator
        function generateId() {
            return `r-${reminderIdCounter++}`;
        }

        // Logs messages to the output log box
        function log(message) {
            const logElement = document.getElementById('outputLog');
            logElement.innerHTML += `> ${message}\n`;
            logElement.scrollTop = logElement.scrollHeight;
        }

        // Function to play a short beep
        function playAlertSound() {
            try {
                const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                const oscillator = audioCtx.createOscillator();
                const gainNode = audioCtx.createGain();

                oscillator.connect(gainNode);
                gainNode.connect(audioCtx.destination);

                oscillator.type = 'square';
                oscillator.frequency.setValueAtTime(440, audioCtx.currentTime); 
                gainNode.gain.setValueAtTime(0.5, audioCtx.currentTime);

                gainNode.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.3);

                oscillator.start();
                oscillator.stop(audioCtx.currentTime + 0.3);
            } catch (e) {
                console.error("Audio playback error:", e);
                // Non-critical, just log the error
            }
        }
        
        // Finds the closest timestamp in the input to start parsing
        function findTimeKeywordIndex(text) {
            const keywords = [' on ', ' in ', ' at '];
            for (const keyword of keywords) {
                // Use lastIndexOf to ensure we capture the time phrase at the end
                const index = text.toLowerCase().lastIndexOf(keyword);
                if (index !== -1) {
                    return index + keyword.length - 1; // Position right after the keyword
                }
            }
            return -1;
        }
        
        // Converts a time phrase (e.g., "5 minutes" or "5s") into a Date object
        function parseTimePhrase(phrase, baseDate = new Date()) {
            phrase = phrase.trim().toLowerCase();
            if (!phrase) return null;

            // CRITICAL FIX: Handle variations like "for 5 minutes", "5 more seconds", or just "5s"
            const relaxedPhrase = phrase.replace(/^(for|in|more)\s+/, '').trim();
            
            // Regex for relative time: (Number) (Unit)
            const relativeMatch = relaxedPhrase.match(/^(\d+)\s*(s|sec|seconds|m|min|minutes|h|hr|hours|d|day|days)$/i);
            
            if (relativeMatch) {
                const value = parseInt(relativeMatch[1], 10);
                const unit = relativeMatch[2].toLowerCase();
                const newDate = new Date(baseDate.getTime());
                
                if (['s', 'sec', 'seconds'].includes(unit)) newDate.setSeconds(newDate.getSeconds() + value);
                else if (['m', 'min', 'minutes'].includes(unit)) newDate.setMinutes(newDate.getMinutes() + value);
                else if (['h', 'hr', 'hours'].includes(unit)) newDate.setHours(newDate.getHours() + value);
                else if (['d', 'day', 'days'].includes(unit)) newDate.setDate(newDate.getDate() + value);
                
                return newDate;
            }
            
            return null;
        }
        
        // Formats the Date object into a readable string
        function formatTime(date) {
            if (!date) return 'N/A';
            const now = new Date();
            const timeDifference = date.getTime() - now.getTime();
            
            if (timeDifference < 0) return 'Past Due';

            const seconds = Math.floor(timeDifference / 1000);
            const minutes = Math.floor(seconds / 60);
            const hours = Math.floor(minutes / 60);
            const days = Math.floor(hours / 24);

            if (days > 0) return `in ${days} day(s)`;
            if (hours > 0) return `in ${hours} hr(s)`;
            if (minutes > 0) return `in ${minutes} min(s)`;
            if (seconds > 0) return `in ${seconds} sec(s)`;
            
            return 'Now';
        }

        // --- Reminder Actions ---

        // Adds or updates a reminder
        function handleSetTask(input) {
            // Check for a time keyword surrounded by spaces for better separation
            const timeIndex = findTimeKeywordIndex(input); 
            if (timeIndex === -1) {
                log('Error: Could not find a time keyword (on, in, at). Command format must be: [Task] in [Time].');
                return;
            }

            const keyword = input.substring(timeIndex - 2, timeIndex + 1); // e.g., ' in '
            const taskDescription = input.substring(0, timeIndex - keyword.length + 1).trim();
            const timePhrase = input.substring(timeIndex + 1).trim();
            const targetDate = parseTimePhrase(timePhrase);

            if (!targetDate) {
                log(`Error: Could not parse time phrase "${timePhrase}". Please use simple relative time (e.g., 5s, 10m, 1h).`);
                return;
            }

            if (!taskDescription) {
                 log('Error: Task description cannot be empty.');
                 return;
            }

            const newReminder = {
                id: generateId(),
                task: taskDescription,
                targetTime: targetDate.getTime(),
                isAlerting: false,
                isDismissed: false,
                isDeleted: false,
            };

            reminderList.push(newReminder);
            log(`Task "${taskDescription}" set for ${formatTime(targetDate)}.`);
            renderReminders();
        }

        function handleSnooze(id, input) {
            const reminder = reminderList.find(r => r.id === id);
            if (!reminder) return;

            // Extract time phrase after "snooze"
            let timePhrase = input.toLowerCase().replace('snooze', '').trim();
            
            // If the remaining phrase is empty or just prepositions, use default
            if (!timePhrase || timePhrase === 'for' || timePhrase === 'in') {
                timePhrase = '5 minutes'; 
            }
            
            // Allow full commands like "snooze for 5 minutes" or simple "5 minutes"
            const now = new Date();
            const snoozeTime = parseTimePhrase(timePhrase, now);

            if (!snoozeTime) {
                log(`Error: Could not parse snooze time "${timePhrase}". Using default 5 minutes.`);
                return handleSnooze(id, '5 minutes'); // Retry with default
            }

            reminder.targetTime = snoozeTime.getTime();
            reminder.isAlerting = false;
            
            const timeStr = formatTime(snoozeTime);
            log(`Reminder "${reminder.task}" snoozed. New alert: ${timeStr}.`);
            renderReminders();
            // We call this to stop the continuous sound from the main loop
        }

        function handleDismiss(id) {
            const reminder = reminderList.find(r => r.id === id);
            if (reminder) {
                reminder.isDismissed = true;
                reminder.isAlerting = false;
                log(`Reminder "${reminder.task}" dismissed. It remains in the list for reference.`);
                renderReminders();
            }
        }

        function handleDelete(id) {
            const reminder = reminderList.find(r => r.id === id);
            if (reminder) {
                reminder.isDeleted = true;
                reminder.isAlerting = false;
                log(`Reminder "${reminder.task}" permanently deleted.`);
                renderReminders();
            }
        }
        
        // --- Input Handling ---

        function handleInput(rawInput) {
            document.getElementById('commandInput').value = '';
            const input = rawInput.trim();
            if (!input) return;
            
            const normalizedInput = input.toLowerCase();

            // 1. Find the currently alerting item (if any)
            const alertingItem = reminderList.find(r => r.isAlerting);

            // --- CRITICAL FIX: Prioritize Alert Handling Commands (highest priority) ---
            if (alertingItem) {
                // A. Check for exact match for dismiss and delete
                if (normalizedInput === 'dismiss') {
                    handleDismiss(alertingItem.id);
                    return; // STOP EXECUTION
                }
                
                if (normalizedInput === 'delete') {
                    handleDelete(alertingItem.id);
                    return; // STOP EXECUTION
                }
                
                // B. Check for snooze (must start with 'snooze')
                if (normalizedInput.startsWith('snooze')) {
                    // Pass the whole input string to handleSnooze for proper parsing
                    handleSnooze(alertingItem.id, input);
                    return; // STOP EXECUTION
                }

                // If an item is alerting but the input is none of the alert commands,
                // we fall through to the new task setting logic.
            }
            // --- End CRITICAL FIX Block ---
            
            // 2. If no alert command was processed, treat it as a new task command.
            handleSetTask(input);
        }

        // --- Rendering ---

        function renderReminders() {
            const container = document.getElementById('reminderListContainer');
            const countElement = document.getElementById('reminderCount');
            
            const activeReminders = reminderList.filter(r => !r.isDeleted);
            
            container.innerHTML = activeReminders.map(r => {
                const isPastDue = r.targetTime < Date.now();
                const isAlertingClass = r.isAlerting ? 'reminder-alerting' : '';
                
                let timeText;
                let statusColor;

                if (r.isDismissed) {
                    timeText = 'DISMISSED';
                    statusColor = 'text-gray-400';
                } else if (r.isAlerting) {
                    timeText = 'ALERTING NOW!';
                    statusColor = 'text-red-600 font-bold';
                } else if (isPastDue) {
                    timeText = 'Overdue - Awaiting Action';
                    statusColor = 'text-orange-500';
                } else {
                    timeText = formatTime(new Date(r.targetTime));
                    statusColor = 'text-indigo-600';
                }
                
                return `
                    <div class="reminder-item p-4 rounded-lg flex justify-between items-center ${isAlertingClass}">
                        <div class="flex-grow">
                            <p class="font-semibold text-gray-800">${r.task}</p>
                            <p class="text-sm ${statusColor}">Status: ${timeText}</p>
                        </div>
                    </div>
                `;
            }).join('');

            countElement.textContent = activeReminders.length;
        }

        // --- Main Loop and Event Listeners ---

        // The main check loop runs every second
        function checkReminders() {
            const now = Date.now();
            let shouldPlaySound = false;

            reminderList.forEach(r => {
                // If it's time and not already alerting, dismissed, or deleted, set to alerting
                if (!r.isDismissed && !r.isDeleted && !r.isAlerting && r.targetTime <= now) {
                    r.isAlerting = true;
                    log(`ALERT: "${r.task}" is due! Type 'dismiss', 'delete', or 'snooze for [time]'.`);
                }
                
                // If any item is alerting, we need to play the sound
                if (r.isAlerting) {
                    shouldPlaySound = true;
                }
            });

            if (shouldPlaySound) {
                playAlertSound();
            }

            renderReminders();
        }

        // Initialize and bind events
        document.addEventListener('DOMContentLoaded', () => {
            document.getElementById('sendButton').addEventListener('click', () => {
                const input = document.getElementById('commandInput').value;
                handleInput(input);
            });

            document.getElementById('commandInput').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    const input = document.getElementById('commandInput').value;
                    handleInput(input);
                }
            });

            // Start the check loop
            setInterval(checkReminders, 1000);
            
            // No need to init synth on click since playAlertSound handles it internally
        });
    </script>
</body>
</html>
