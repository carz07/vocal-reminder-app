<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vocal Reminder App</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            min-height: 100vh;
            background-color: #f7f9fc;
        }
        .mic-button {
            transition: all 0.2s ease;
        }
        .mic-button:hover {
            transform: scale(1.05);
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
        }
        .listening {
            animation: pulse-ring 1.5s infinite;
        }
        @keyframes pulse-ring {
            0% { box-shadow: 0 0 0 0 rgba(76, 29, 149, 0.4); }
            70% { box-shadow: 0 0 0 20px rgba(76, 29, 149, 0); }
            100% { box-shadow: 0 0 0 0 rgba(76, 29, 149, 0); }
        }
        .alarm-active {
            animation: alarm-shake 0.5s infinite;
            border-color: #ef4444 !important;
        }
        @keyframes alarm-shake {
            0%, 100% { transform: translateX(0); }
            20%, 60% { transform: translateX(-5px); }
            40%, 80% { transform: translateX(5px); }
        }
        .countdown-time {
            /* Ensure the countdown is easily visible */
            font-weight: 600;
            color: #4f46e5; /* Indigo-600 */
        }
    </style>
</head>
<body class="p-4 md:p-8 flex flex-col items-center">

    <!-- The ID was changed from 'app-container' to 'app-card' to better reflect its purpose and avoid potential confusion -->
    <div id="app-card" class="w-full max-w-lg bg-white p-6 md:p-8 rounded-xl shadow-2xl transition-all duration-500 border-4 border-indigo-100">

        <h1 class="text-3xl font-bold text-gray-800 mb-2 text-center">Vocal Reminders</h1>
        <p class="text-center text-sm text-gray-500 mb-6">Your voice-activated personal assistant.</p>

        <!-- Status Display -->
        <div id="status-box" class="p-4 rounded-lg text-center font-medium bg-indigo-50 text-indigo-700 mb-6 border border-indigo-200 min-h-[5rem] flex items-center justify-center">
            Welcome! Click the microphone or type below to set reminders, including specific dates.
        </div>

        <!-- Microphone Button -->
        <div class="flex justify-center mb-6">
            <button id="mic-btn" class="mic-button p-6 rounded-full bg-indigo-600 text-white shadow-xl hover:bg-indigo-700 focus:outline-none focus:ring-4 focus:ring-indigo-300 transition-all duration-200">
                <!-- Simple Microphone Icon -->
                <svg xmlns="http://www.w3.org/2000/svg" class="h-10 w-10" viewBox="0 0 20 20" fill="currentColor">
                    <path d="M7 4a3 3 0 016 0v4a3 3 0 11-6 0V4z" />
                    <path fill-rule="evenodd" d="M3 8a1 1 0 011 1v3.5A6.5 6.5 0 0017 12.5V9a1 1 0 112 0v3.5a8.5 8.5 0 01-17 0V9a1 1 0 011-1z" clip-rule="evenodd" />
                </svg>
            </button>
        </div>
        
        <!-- Manual Input Box -->
        <div class="mb-8 p-4 bg-gray-50 rounded-xl shadow-inner border border-gray-200">
            <label for="reminder-input" class="block text-sm font-medium text-gray-700 mb-2">Or, Type Your Reminder or Command:</label>
            <div class="flex space-x-2">
                <input 
                    type="text" 
                    id="reminder-input" 
                    class="flex-grow p-3 border border-gray-300 rounded-lg focus:ring-indigo-500 focus:border-indigo-500 text-base shadow-sm"
                    placeholder='e.g., "Call Mom on Dec 25 at 11:30am", "snooze 5m", or "dismiss"'
                >
                <button 
                    id="set-manual-btn"
                    class="px-3 py-3 bg-indigo-500 text-white font-semibold rounded-lg shadow-md hover:bg-indigo-600 transition-colors flex-shrink-0 flex items-center justify-center"
                    title="Set Reminder"
                >
                    <!-- Document Plus Icon: Represents setting/adding a new reminder (writing a note) -->
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" class="w-5 h-5">
                        <path fill-rule="evenodd" d="M4 2a2 2 0 00-2 2v12a2 2 0 002 2h8a2 2 0 002-2V7.757a2 2 0 00-.586-1.414L9.757 2.586A2 2 0 008.343 2H4zm6 6.5a.75.75 0 00-1.5 0v1.5H7.5a.75.75 0 000 1.5h1.5v1.5a.75.75 0 001.5 0v-1.5h1.5a.75.75 0 000-1.5h-1.5v-1.5z" clip-rule="evenodd" />
                    </svg>
                </button>
            </div>
        </div>


        <!-- Reminders List -->
        <h2 class="text-xl font-semibold text-gray-700 mb-4 border-b pb-2">Active Reminders</h2>
        <ul id="reminders-list" class="space-y-3">
            <li class="text-gray-500 italic">No reminders set.</li>
        </ul>
    </div>

    <script>
        // --- Core Application State & Constants ---
        const $ = (id) => document.getElementById(id);
        const STATUS_BOX = $('status-box');
        const MIC_BTN = $('mic-btn');
        // FIX: Corrected ID lookup to 'app-card'
        const APP_CONTAINER = $('app-card'); 
        const REMINDERS_LIST = $('reminders-list');
        const REMINDER_INPUT = $('reminder-input');
        const SET_MANUAL_BTN = $('set-manual-btn');

        let reminders = [];
        let activeAlarm = null;
        let recognition = null;
        let alarmIntervalId = null;
        let audioContext = null;

        const MONTH_MAP = {
            'january': 0, 'jan': 0, 'february': 1, 'feb': 1, 'march': 2, 'mar': 2, 
            'april': 3, 'apr': 3, 'may': 4, 'june': 5, 'jun': 5, 'july': 6, 'jul': 6, 
            'august': 7, 'aug': 7, 'september': 8, 'sep': 8, 'october': 9, 'oct': 9, 
            'november': 10, 'nov': 10, 'december': 11, 'dec': 11
        };

        // --- Utility Functions ---

        /** Sets the status message and speaks it if necessary. */
        function setStatus(message, speak = false) {
            console.log("Status: " + message);
            STATUS_BOX.textContent = message;
            if (speak) {
                speakText(message);
            }
        }

        /** Text-to-Speech function. */
        function speakText(text) {
            if ('speechSynthesis' in window) {
                window.speechSynthesis.cancel();
                const utterance = new SpeechSynthesisUtterance(text);
                utterance.voice = window.speechSynthesis.getVoices().find(voice => voice.name.includes('Google US English')) || window.speechSynthesis.getVoices()[0];
                utterance.rate = 1.1;
                window.speechSynthesis.speak(utterance);
            } else {
                console.warn('Speech Synthesis not supported.');
            }
        }

        /** Parses a complex time phrase (relative or absolute) into a Date object. */
        function parseReminderTime(phrase) {
            phrase = phrase.trim().toLowerCase();
            const now = new Date();
            let futureTime = new Date(now.getTime());

            // --- 0. KEYWORD DATE PARSING (Handles "tomorrow" or "today") ---
            if (phrase.includes('tomorrow')) {
                futureTime.setDate(futureTime.getDate() + 1);
            } else if (phrase.includes('today')) {
                // If the time is set in the past, it will roll over to the next day later.
            }
            // Remove keywords so they don't interfere with later parsing
            phrase = phrase.replace('tomorrow', '').replace('today', '').trim();


            // --- 1. RELATIVE TIME PARSING (e.g., "in 5 minutes", "in 3 hours") ---
            // Added check for "next week/day" to handle common phrases without "in"
            const relativeMatch = phrase.match(/(?:in|after|for) (\d+|a|an|one) (minutes?|hours?|seconds?|min|sec|hr|day|week|month|year)s?/i) ||
                                  phrase.match(/(next|this) (day|week|month|year)/i);
            
            if (relativeMatch) {
                if (relativeMatch[1] === 'next' || relativeMatch[1] === 'this') {
                    const unit = relativeMatch[2].toLowerCase();
                    
                    if (unit.startsWith('week')) {
                        futureTime.setDate(futureTime.getDate() + 7);
                    } else if (unit.startsWith('day')) {
                        futureTime.setDate(futureTime.getDate() + 1);
                    } else if (unit.startsWith('month')) {
                        futureTime.setMonth(futureTime.getMonth() + 1);
                    } else if (unit.startsWith('year')) {
                        futureTime.setFullYear(futureTime.getFullYear() + 1);
                    }
                } else {
                    let value = parseInt(relativeMatch[1]);
                    if (isNaN(value)) {
                        value = (relativeMatch[1].toLowerCase() === 'one' || relativeMatch[1].toLowerCase() === 'a' || relativeMatch[1].toLowerCase() === 'an') ? 1 : 0;
                    }
                    const unit = relativeMatch[2].toLowerCase();

                    if (unit.startsWith('minute') || unit === 'min') {
                        futureTime.setMinutes(futureTime.getMinutes() + value);
                    } else if (unit.startsWith('hour') || unit === 'hr') {
                        futureTime.setHours(futureTime.getHours() + value);
                    } else if (unit.startsWith('second') || unit === 'sec') {
                        futureTime.setSeconds(futureTime.getSeconds() + value);
                    } else if (unit.startsWith('day')) {
                        futureTime.setDate(futureTime.getDate() + value);
                    } else if (unit.startsWith('week')) {
                        futureTime.setDate(futureTime.getDate() + (value * 7));
                    } else if (unit.startsWith('month')) {
                        futureTime.setMonth(futureTime.getMonth() + value);
                    } else if (unit.startsWith('year')) {
                        futureTime.setFullYear(futureTime.getFullYear() + value);
                    }
                }
                
                // If relative time puts us in the past (e.g., "in 5 minutes" was called at 12:00:00 and now it's 12:00:01)
                // We ensure it is at least 1 second in the future.
                if (futureTime.getTime() <= now.getTime()) {
                    futureTime = new Date(now.getTime() + 1000);
                }

                return futureTime;
            }

            // --- 2. ABSOLUTE DATE/TIME PARSING (e.g., "October 25 at 11am") ---
            // Regex captures: [Month Name/Abbr] [Day] (optional: at [Hour:Minute] [AM/PM])
            const absoluteMatch = phrase.match(/([a-z]+) (\d{1,2})(?: at (\d{1,2})(?::(\d{1,2}))? ?(am|pm)?)?/i);

            if (absoluteMatch) {
                const monthStr = absoluteMatch[1];
                const day = parseInt(absoluteMatch[2]);
                let hour = parseInt(absoluteMatch[3] || '0');
                let minute = parseInt(absoluteMatch[4] || '0');
                const ampm = absoluteMatch[5] ? absoluteMatch[5].toLowerCase() : null;

                const month = MONTH_MAP[monthStr];
                if (month === undefined || isNaN(day) || day < 1 || day > 31) {
                    setStatus('I found a date but the month or day is invalid.', true);
                    return null;
                }

                // If a date was set via tomorrow/today in step 0, we preserve that date, 
                // otherwise we set the month/day/year based on input.
                if (futureTime.getDate() !== now.getDate() || futureTime.getMonth() !== now.getMonth()) {
                    // Date was set by 'tomorrow', so we only overwrite time.
                } else {
                    // Set the date based on input
                    futureTime.setFullYear(now.getFullYear(), month, day);
                }


                // Adjust for 12/24 hour time
                if (ampm === 'pm' && hour < 12) {
                    hour += 12;
                } else if (ampm === 'am' && hour === 12) {
                    hour = 0; // Midnight 12 AM is 0 hour
                }
                
                // Set the time
                futureTime.setHours(hour, minute, 0, 0);

                // Handle Year Rollover: If the set date/time is in the past, push it to next year.
                if (futureTime.getTime() < now.getTime()) {
                    const originalYear = futureTime.getFullYear();
                    futureTime.setFullYear(originalYear + 1);
                    setStatus(`Setting reminder for next year (${futureTime.getFullYear()}) as the specified date has passed this year.`, false);
                }

                return futureTime;
            }

            // --- 3. PARSING FOR SIMPLE TIME (e.g., "at 5pm" when the date is already known) ---
             const simpleTimeMatch = phrase.match(/(?:at|by) (\d{1,2})(?::(\d{1,2}))? ?(am|pm)?/i);

            if (simpleTimeMatch) {
                let hour = parseInt(simpleTimeMatch[1] || '0');
                let minute = parseInt(simpleTimeMatch[2] || '0');
                const ampm = simpleTimeMatch[3] ? simpleTimeMatch[3].toLowerCase() : null;

                // Adjust for 12/24 hour time
                if (ampm === 'pm' && hour < 12) {
                    hour += 12;
                } else if (ampm === 'am' && hour === 12) {
                    hour = 0;
                }

                futureTime.setHours(hour, minute, 0, 0);

                // If setting a simple time (e.g., "at 5pm") and the time is now in the past
                if (futureTime.getTime() < now.getTime() && (futureTime.getDate() === now.getDate())) {
                    // Push to tomorrow if the time is today but in the past
                    futureTime.setDate(futureTime.getDate() + 1);
                }
                
                if (futureTime.getTime() <= now.getTime()) {
                    futureTime = new Date(now.getTime() + 1000); // Ensure at least 1 second in future
                }
                
                return futureTime;
            }


            // --- 4. PARSING FAILED ---
            setStatus('I could not parse the date or duration. Try "October 25 at 11am" or "in 5 minutes".', true);
            return null;
        }


        /** Parses a snooze duration phrase into milliseconds. */
        function parseDuration(phrase) {
            phrase = phrase.trim().toLowerCase();
            const timeMatch = phrase.match(/(\d+|a|an|one) (minutes?|hours?|seconds?|min|sec|hr)/i);
            
            if (timeMatch) {
                let value = parseInt(timeMatch[1]);
                if (isNaN(value)) {
                    value = (timeMatch[1].toLowerCase() === 'one' || timeMatch[1].toLowerCase() === 'a' || timeMatch[1].toLowerCase() === 'an') ? 1 : 0;
                }
                const unit = timeMatch[2].toLowerCase();

                if (unit.startsWith('minute') || unit === 'min') {
                    return value * 60 * 1000;
                } else if (unit.startsWith('hour') || unit === 'hr') {
                    return value * 3600 * 1000;
                } else if (unit.startsWith('second') || unit === 'sec') {
                    return value * 1000;
                }
            } 
            
            const secondsMatch = phrase.match(/^(\d+)$/);
            if (secondsMatch) {
                const seconds = parseInt(secondsMatch[1]);
                if (seconds > 7200) {
                     setStatus("Snooze time must be less than 2 hours.", true);
                     return null;
                }
                return seconds * 1000;
            }

            return null;
        }

        /** Formats milliseconds into a human-readable Hh M:SS string. */
        function formatTimeDifference(ms) {
            if (ms < 0) return "DUE NOW!";
            
            let seconds = Math.floor(ms / 1000);
            const hours = Math.floor(seconds / 3600);
            seconds %= 3600;
            const minutes = Math.floor(seconds / 60);
            seconds %= 60;

            const pad = (num) => String(num).padStart(2, '0');

            if (hours > 0) {
                return `${hours}h ${pad(minutes)}m ${pad(seconds)}s`;
            } else if (minutes > 0) {
                return `${minutes}m ${pad(seconds)}s`;
            } else {
                return `${seconds}s`;
            }
        }

        // --- Reminder Logic ---

        /** Adds a new reminder to the list. */
        function addReminder(text, time) {
            const id = Date.now();
            reminders.push({ id, text, time, isActive: false, alarmTimeoutId: null });
            
            const timeOptions = { weekday: 'short', year: 'numeric', month: 'short', day: 'numeric', hour: '2-digit', minute: '2-digit' };
            setStatus(`Reminder set for "${text}" on ${time.toLocaleDateString('en-US', timeOptions)}.`, true);
            
            renderReminders();
        }

        /** Clears a reminder by ID or by matching the text. */
        function clearReminder(idOrText) {
            const initialLength = reminders.length;

            if (typeof idOrText === 'number') {
                reminders = reminders.filter(r => r.id !== idOrText);
            } else {
                const text = idOrText.toLowerCase();
                const index = reminders.findIndex(r => r.text.toLowerCase().includes(text));
                if (index !== -1) {
                    reminders.splice(index, 1);
                }
            }

            if (reminders.length < initialLength) {
                setStatus("The reminder has been dismissed.", true);
                renderReminders();
                if (activeAlarm && (activeAlarm.id === idOrText || (typeof idOrText === 'string' && activeAlarm.text.toLowerCase().includes(idOrText.toLowerCase())))) {
                    stopAlarm();
                }
                return true;
            }
            return false;
        }

        /** Triggers the alarm sequence for a reminder. */
        function triggerAlarm(reminder) {
            if (activeAlarm) return;

            activeAlarm = reminder;
            APP_CONTAINER.classList.add('alarm-active');
            setStatus(`ALARM: Time for "${reminder.text}"! Say or type "Snooze" or "Dismiss."`, true);

            playAlarmSound();
            reminder.isActive = true;
            renderReminders();
        }

        /** Stops the current alarm. */
        function stopAlarm() {
            if (activeAlarm) {
                stopAlarmSound();
                activeAlarm.isActive = false;
                activeAlarm = null;
                APP_CONTAINER.classList.remove('alarm-active');
                renderReminders();
            }
        }

        /** Plays a simple beeping sound using AudioContext. */
        function playAlarmSound() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }
            if (alarmIntervalId) clearInterval(alarmIntervalId);

            let isPlaying = false;

            const beep = () => {
                if (isPlaying) return;
                isPlaying = true;
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();

                oscillator.type = 'square';
                oscillator.frequency.setValueAtTime(880, audioContext.currentTime);
                gainNode.gain.setValueAtTime(0.5, audioContext.currentTime);

                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);

                oscillator.start();
                
                gainNode.gain.exponentialRampToValueAtTime(0.00001, audioContext.currentTime + 0.2);
                oscillator.stop(audioContext.currentTime + 0.2);
                setTimeout(() => { isPlaying = false; }, 200);
            };

            beep();
            alarmIntervalId = setInterval(beep, 700);
        }

        /** Stops the simple alarm sound. */
        function stopAlarmSound() {
            if (alarmIntervalId) {
                clearInterval(alarmIntervalId);
                alarmIntervalId = null;
            }
        }


        /** Snoozes the current active alarm for a specified duration in milliseconds. */
        function snoozeAlarm(durationMs = 5 * 60 * 1000) {
            if (!activeAlarm) {
                setStatus("There is no active alarm to snooze.", true);
                return;
            }
            const newTime = new Date(Date.now() + durationMs);

            let displayDuration;
            if (durationMs < 60000) {
                displayDuration = `${durationMs / 1000} seconds`;
            } else if (durationMs < 3600000) {
                const minutes = Math.floor(durationMs / 60000);
                const seconds = Math.floor((durationMs % 60000) / 1000);
                
                if (seconds > 0) {
                    displayDuration = `${minutes} minute${minutes !== 1 ? 's' : ''} and ${seconds} second${seconds !== 1 ? 's' : ''}`;
                } else {
                     displayDuration = `${minutes} minute${minutes !== 1 ? 's' : ''}`;
                }
            } else {
                displayDuration = `${durationMs / 3600000} hours`;
            }


            activeAlarm.time = newTime;
            activeAlarm.isActive = false;
            
            setStatus(`Alarm snoozed for ${displayDuration}. New time is ${newTime.toLocaleTimeString()}.`, true);
            stopAlarm();
            renderReminders();
        }

        /** Loop to check if any reminders are due. */
        function checkReminders() {
            const now = new Date();
            for (let reminder of reminders) {
                if (!reminder.isActive && reminder.time <= now) {
                    triggerAlarm(reminder);
                }
            }
        }
        
        /** Updates the countdown display for all reminders. */
        function updateCountdowns() {
            const now = Date.now();
            for (const reminder of reminders) {
                const countdownElement = $(`countdown-${reminder.id}`);
                
                if (countdownElement) {
                    if (!reminder.isActive) { 
                        const diff = reminder.time.getTime() - now;
                        countdownElement.textContent = formatTimeDifference(diff);
                        
                        if (diff < 60000 && diff > 0) { // Less than 1 minute (but not yet due)
                            countdownElement.classList.remove('text-indigo-500');
                            countdownElement.classList.add('text-orange-500');
                        } else {
                            countdownElement.classList.remove('text-orange-500');
                            countdownElement.classList.add('text-indigo-500');
                        }

                    } else {
                        countdownElement.textContent = "ALARM RINGING";
                    }
                }
            }
        }

        /** Main loop to check alarms and update the display. */
        function mainLoop() {
            checkReminders(); 
            updateCountdowns();
        }
        
        // --- UI Action Handlers ---

        /** Handles deletion triggered by the UI button. */
        function deleteReminderUI(id) {
            setStatus("Deleting reminder.", true);
            clearReminder(id);
        }
        
        /** Handles setting a reminder via the manual text input, including snooze/dismiss commands. */
        function handleManualSet() {
            const input = REMINDER_INPUT.value.trim();
            const lowerInput = input.toLowerCase();

            if (!input) {
                setStatus("Please enter a reminder phrase or command in the box.", true);
                return;
            }

            // 1. Snooze Command
            if (lowerInput.startsWith('snooze')) {
                let durationMs = 5 * 60 * 1000;
                const durationPhrase = input.substring('snooze'.length).trim();
                
                if (durationPhrase.length > 0) {
                    const parsedDuration = parseDuration(durationPhrase);

                    if (parsedDuration !== null && parsedDuration > 0) {
                        durationMs = parsedDuration;
                    } else if (durationPhrase !== "") {
                        setStatus("Snooze command recognized, but I could not parse the duration. Using default 5 minutes.", true);
                    }
                }
                
                snoozeAlarm(durationMs);
                REMINDER_INPUT.value = '';
                return;
            }
            
            // 2. Dismiss Command
            if (lowerInput === 'dismiss') {
                if (activeAlarm) {
                    clearReminder(activeAlarm.id); 
                    REMINDER_INPUT.value = '';
                    return;
                } else {
                    setStatus("There is no active alarm to dismiss.", true);
                    REMINDER_INPUT.value = '';
                    return;
                }
            }

            // 3. Process as a new Reminder 
            // FIX: Added 'by', 'next', 'tomorrow', 'today' to the list of acceptable separators to improve flexibility.
            const manualMatch = input.match(/(.+?) (?:at|in|on|for|by|next|tomorrow|today) (.+)/i);

            if (manualMatch && manualMatch.length === 3) {
                const text = manualMatch[1].trim();
                const timePhrase = manualMatch[2].trim();
                const time = parseReminderTime(timePhrase);
                
                if (time) {
                    addReminder(text, time);
                    REMINDER_INPUT.value = '';
                } else {
                     setStatus("I couldn't parse the time from your input. Try 'Task on Dec 25 at 11am', 'Task tomorrow at 5pm', or 'Task in 5 minutes'.", true);
                }
            } else {
                setStatus("I couldn't parse that. Please use a clear format like 'Task on [date] at [time]' or 'Task in [duration]'.", true);
            }
        }


        // --- UI Rendering ---

        function renderReminders() {
            if (reminders.length === 0) {
                REMINDERS_LIST.innerHTML = '<li class="text-gray-500 italic p-3">No reminders set.</li>';
                return;
            }

            REMINDERS_LIST.innerHTML = reminders
                .sort((a, b) => a.time - b.time)
                .map(r => {
                    const statusClass = r.isActive ? 'bg-red-100 text-red-800 border-red-400' : 'bg-white text-gray-800 border-gray-200';
                    const timeOptions = { month: 'short', day: 'numeric', hour: '2-digit', minute: '2-digit' };
                    const timeString = r.time.toLocaleDateString('en-US', timeOptions);

                    return `
                        <li class="p-3 rounded-lg flex justify-between items-center shadow-md transition-shadow border-2 ${statusClass}">
                            <div class="flex flex-col flex-grow min-w-0 pr-4">
                                <span class="text-base font-semibold truncate">${r.text}</span>
                                <span id="countdown-${r.id}" class="text-sm font-mono countdown-time mt-1">Calculating...</span>
                            </div>
                            <div class="flex items-center space-x-3 flex-shrink-0">
                                <!-- Original set time and date for reference -->
                                <span class="text-xs text-gray-500 hidden sm:inline">@ ${timeString}</span>
                                <button 
                                    class="text-red-500 hover:text-red-700 p-1 rounded-full hover:bg-red-100 transition-colors"
                                    onclick="deleteReminderUI(${r.id})"
                                    title="Delete Reminder"
                                >
                                    <!-- Trash Icon -->
                                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                                      <path fill-rule="evenodd" d="M9 2a1 1 0 00-.894.553L7.382 4H4a1 1 0 000 2v10a2 2 0 002 2h8a2 2 0 002-2V6a1 1 0 100-2h-3.382l-.724-1.447A1 1 0 0011 2H9zM7 8a1 1 0 012 0v6a1 1 0 11-2 0V8zm4 0a1 1 0 10-2 0v6a1 1 0 102 0V8z" clip-rule="evenodd" />
                                    </svg>
                                </button>
                            </div>
                        </li>
                    `;
                })
                .join('');
             updateCountdowns();
        }

        // --- Speech Recognition Setup & Handler ---

        function setupSpeechRecognition() {
            if (!('webkitSpeechRecognition' in window)) {
                STATUS_BOX.textContent = "Speech Recognition not supported in this browser.";
                MIC_BTN.disabled = true;
                return;
            }

            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            recognition = new SpeechRecognition();
            recognition.continuous = false;
            recognition.lang = 'en-US';
            recognition.interimResults = false;

            recognition.onstart = () => {
                MIC_BTN.classList.add('listening');
                setStatus("Listening... Speak your command now.");
            };

            recognition.onresult = (event) => {
                const transcript = event.results[0][0].transcript;
                MIC_BTN.classList.remove('listening');
                handleVoiceCommand(transcript);
            };

            recognition.onerror = (event) => {
                MIC_BTN.classList.remove('listening');
                if (event.error === 'not-allowed') {
                    setStatus("Microphone permission denied. Please allow access in your browser settings.", true);
                } else if (event.error === 'no-speech') {
                     setStatus("No speech detected. Please try again.", true);
                } else {
                    setStatus(`Speech recognition error: ${event.error}`, true);
                }
            };

            recognition.onend = () => {
                MIC_BTN.classList.remove('listening');
            };

            MIC_BTN.onclick = () => {
                if (MIC_BTN.classList.contains('listening')) {
                    recognition.stop();
                } else {
                    // Stop any ongoing speech synthesis before starting to listen
                    window.speechSynthesis.cancel();
                    recognition.start();
                }
            };
        }
        
        function handleVoiceCommand(transcript) {
            MIC_BTN.classList.remove('listening'); // Ensure class is removed immediately
            const lowerTranscript = transcript.toLowerCase();
            
            // 1. Snooze/Dismiss when Alarm is Active
            if (activeAlarm) {
                if (lowerTranscript.includes('snooze')) {
                    const snoozeMatch = lowerTranscript.match(/snooze for (.+)/) || lowerTranscript.match(/snooze (.+)/);
                    let durationMs = 5 * 60 * 1000;
                    if (snoozeMatch) {
                        const parsedDuration = parseDuration(snoozeMatch[1]);
                        if (parsedDuration !== null && parsedDuration > 0) {
                            durationMs = parsedDuration;
                        }
                    }
                    snoozeAlarm(durationMs);
                    return;
                } else if (lowerTranscript.includes('dismiss') || lowerTranscript.includes('clear')) {
                    clearReminder(activeAlarm.id);
                    return;
                }
            }
            
            // 2. Set New Reminder (Voice Command)
            // Tries to match: "set a reminder for [task] (on|in|at) [time phrase]"
            const match = lowerTranscript.match(/set a reminder for (.+?) (?:on|in|at) (.+)/);
            
            if (match && match.length === 3) {
                const text = match[1].trim();
                const timePhrase = match[2].trim();
                const time = parseReminderTime(timePhrase);
                
                if (time) {
                    addReminder(text, time);
                }
                return;
            }

            // 3. Fallback for Unmatched Commands
            setStatus(`I heard "${transcript}" but I couldn't understand that command. Please try "Set a reminder for [task] on October 25 at 11am."`, true);
        }

        // --- Initialization ---

        window.onload = () => {
            SET_MANUAL_BTN.onclick = handleManualSet;
            REMINDER_INPUT.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    handleManualSet();
                }
            });

            setInterval(mainLoop, 1000); 

            if ('speechSynthesis' in window) {
                // Preload voices
                window.speechSynthesis.getVoices();
            }
            setupSpeechRecognition();
            renderReminders();
        };

    </script>
</body>
</html>
