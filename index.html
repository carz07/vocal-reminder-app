<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vocal & Manual Reminder App</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f4f8;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            min-height: 100vh;
        }
        .app-container {
            width: 100%;
            max-width: 550px;
            margin-top: 3rem;
            background: white;
            border-radius: 1.5rem;
            box-shadow: 0 15px 35px rgba(0, 0, 0, 0.1);
            padding: 2rem;
        }
        .mic-button {
            width: 80px;
            height: 80px;
            background-color: #5a67d8; /* Indigo/Purple */
            color: white;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 1.5rem auto;
            cursor: pointer;
            box-shadow: 0 8px 15px rgba(90, 103, 216, 0.5);
            transition: all 0.2s ease;
        }
        .mic-button:hover {
            background-color: #4c51bf;
            transform: scale(1.05);
        }
        .mic-icon {
            width: 40px;
            height: 40px;
        }
        .input-group {
            display: flex;
            gap: 0.5rem;
            align-items: center;
        }
        .input-field {
            flex-grow: 1;
            padding: 0.75rem 1rem;
            border: 2px solid #e2e8f0;
            border-radius: 0.75rem;
            transition: border-color 0.2s, box-shadow 0.2s;
        }
        .input-field:focus {
            outline: none;
            border-color: #5a67d8;
            box-shadow: 0 0 0 2px rgba(90, 103, 216, 0.2);
        }
        /* Style for the Pen Icon button (Set Reminder Action) */
        .set-button {
            background-color: #5a67d8; /* Matching the microphone color */
            color: white;
            border-radius: 0.75rem;
            padding: 0.75rem; /* Padding for square button */
            width: 44px; /* Fixed width/height for square button */
            height: 44px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background-color 0.2s, transform 0.1s;
        }
        .set-button:hover {
            background-color: #4c51bf;
        }
        .set-button:active {
            transform: scale(0.95);
        }
        .log-box {
            background-color: #f7fafc;
            color: #4a5568;
            font-size: 0.8rem;
            white-space: pre-wrap;
            word-break: break-all;
            border-radius: 0.75rem;
            border: 1px solid #e2e8f0;
        }
        .reminder-item {
            padding: 1rem;
            border-radius: 0.75rem;
            /* Update border-left color for dismissed items to be less prominent */
            border-left: 5px solid #5a67d8; 
            background-color: #f7fafc;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);
            transition: all 0.2s ease-in-out;
        }
        /* Style for dismissed items to visually fade them out */
        .reminder-dismissed {
             opacity: 0.6;
             border-left-color: #cbd5e0; /* Lighter gray for dismissed */
        }
        /* Alerting Styles */
        .reminder-alerting {
            background-color: #fee2e2; /* Light Red */
            border-left-color: #e53e3e; /* Darker Red */
            animation: pulse-ring 1s infinite;
        }
        @keyframes pulse-ring {
            0%, 100% {
                box-shadow: 0 0 0 0 rgba(229, 62, 62, 0.4);
            }
            50% {
                box-shadow: 0 0 0 8px rgba(229, 62, 62, 0);
            }
        }
    </style>
</head>
<body>

    <div class="app-container">
        <h1 class="text-3xl font-extrabold text-gray-900 text-center mb-6">Vocal & Manual Reminder App</h1>

        <!-- Microphone Button Area -->
        <div class="text-center">
            <button id="micButton" class="mic-button" title="Type commands below">
                <!-- Microphone SVG Icon -->
                <svg class="mic-icon" fill="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12 14c1.66 0 2.99-1.34 2.99-3L15 5c0-1.66-1.34-3-3-3S9 3.34 9 5v6c0 1.66 1.34 3 3 3zm5.3-3c0 3.01-2.49 5.1-5.3 5.1S6.7 14.01 6.7 11H5c0 3.53 2.61 6.43 6 7v3h2v-3c3.39-.57 6-3.47 6-7h-1.7z"/>
                </svg>
            </button>
            <p id="micStatus" class="text-sm text-gray-500 mb-4">Click to mimic starting a vocal input (Type commands below).</p>
        </div>

        <div class="input-group mb-4">
            <input type="text" id="commandInput" class="input-field" placeholder="e.g., Pay bills in 10s or dismiss">
            <button id="sendButton" class="set-button" title="Set Reminder">
                <!-- Pen Icon -->
                <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M15.232 5.232l3.536 3.536m-2.036-5.036a2.5 2.5 0 113.536 3.536L6.5 21.036H3v-3.572L16.732 3.732z" />
                </svg>
            </button>
        </div>

        <div id="outputLog" class="log-box p-3 mb-6 h-28 overflow-y-auto text-xs">
            System ready. Type a command to begin.
        </div>

        <h2 class="text-xl font-bold text-gray-900 mb-3">Pending Reminders (<span id="reminderCount">0</span>)</h2>
        <div id="reminderListContainer" class="space-y-3">
            <!-- Reminder items will be injected here -->
        </div>
    </div>

    <script>
        // --- Core Setup ---
        let reminderList = [];
        let reminderIdCounter = 1;
        
        // --- Utility Functions ---

        function generateId() {
            return `r-${reminderIdCounter++}`;
        }

        function log(message) {
            const logElement = document.getElementById('outputLog');
            logElement.innerHTML += `> ${message}\n`;
            logElement.scrollTop = logElement.scrollHeight;
        }

        function playAlertSound() {
            try {
                // Generates a short tone for alert feedback
                const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                const oscillator = audioCtx.createOscillator();
                const gainNode = audioCtx.createGain();

                oscillator.connect(gainNode);
                gainNode.connect(audioCtx.destination);

                oscillator.type = 'square';
                oscillator.frequency.setValueAtTime(440, audioCtx.currentTime); 
                gainNode.gain.setValueAtTime(0.5, audioCtx.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.3);

                oscillator.start();
                oscillator.stop(audioCtx.currentTime + 0.3);
            } catch (e) {
                console.error("Audio playback error:", e);
            }
        }
        
        // Finds the time keyword (' in ', ' at ', ' on ') to split task from time
        function findTimeKeywordIndex(text) {
            const keywords = [' in ', ' at ', ' on '];
            for (const keyword of keywords) {
                const index = text.toLowerCase().lastIndexOf(keyword);
                if (index !== -1) {
                    // Return the index right after the keyword (e.g., after ' in ')
                    return index + keyword.length; 
                }
            }
            return -1;
        }
        
        // Parses a time phrase (e.g., "5 seconds", "10m", "for 5 min") into a Date object
        function parseTimePhrase(phrase, baseDate = new Date()) {
            phrase = phrase.trim().toLowerCase();
            if (!phrase) return null;

            // FIX: Remove common noise words, including "more" and extra spaces
            const relaxedPhrase = phrase.replace(/^(for|in|more)\s+/, '').replace(/\s+more\s+/, ' ').trim();
            
            // Regex for relative time: (Number) (Unit)
            const relativeMatch = relaxedPhrase.match(/^(\d+)\s*(s|sec|seconds|m|min|minutes|h|hr|hours|d|day|days)$/i);
            
            if (relativeMatch) {
                const value = parseInt(relativeMatch[1], 10);
                const unit = relativeMatch[2].toLowerCase();
                const newDate = new Date(baseDate.getTime());
                
                if (['s', 'sec', 'seconds'].includes(unit)) newDate.setSeconds(newDate.getSeconds() + value);
                else if (['m', 'min', 'minutes'].includes(unit)) newDate.setMinutes(newDate.getMinutes() + value);
                else if (['h', 'hr', 'hours'].includes(unit)) newDate.setHours(newDate.getHours() + value);
                else if (['d', 'day', 'days'].includes(unit)) newDate.setDate(newDate.getDate() + value);
                
                return newDate;
            }
            
            // NOTE: Full calendar parsing (like "next monday") is excluded for stability
            return null;
        }
        
        // Formats the Date object into a readable time until it's due
        function formatTime(date) {
            if (!date) return 'N/A';
            const timeDifference = date.getTime() - Date.now();
            
            if (timeDifference < 0) return 'Past Due';

            const seconds = Math.floor(timeDifference / 1000);
            const minutes = Math.floor(seconds / 60);
            const hours = Math.floor(minutes / 60);
            const days = Math.floor(hours / 24);

            if (days > 0) return `in ${days} day(s)`;
            if (hours > 0) return `in ${hours} hr(s)`;
            if (minutes > 0) return `in ${minutes} min(s)`;
            if (seconds > 0) return `in ${seconds} sec(s)`;
            
            return 'Now';
        }

        // --- Reminder Actions ---

        function handleSetTask(input) {
            const timeIndex = findTimeKeywordIndex(input); 
            if (timeIndex === -1) {
                log('Error: Could not find a time keyword (on, in, at). Please rephrase the command.');
                return;
            }

            const taskDescription = input.substring(0, timeIndex - 3).trim(); // -3 to remove ' in ' or ' at '
            const timePhrase = input.substring(timeIndex).trim();
            const targetDate = parseTimePhrase(timePhrase);

            if (!targetDate) {
                log(`Error: Could not parse time phrase "${timePhrase}". Please use simple relative time (e.g., 5s, 10m).`);
                return;
            }

            if (!taskDescription) {
                 log('Error: Task description cannot be empty.');
                 return;
            }

            const newReminder = {
                id: generateId(),
                task: taskDescription,
                targetTime: targetDate.getTime(),
                isAlerting: false,
                isDismissed: false,
                isDeleted: false,
                hasAlertedOnce: false, // NEW FLAG to prevent repeated log messages
            };

            reminderList.push(newReminder);
            log(`Task "${taskDescription}" set for ${formatTime(targetDate)}.`);
            renderReminders();
        }

        function handleSnooze(id, input) {
            const reminder = reminderList.find(r => r.id === id);
            if (!reminder) return;

            // Extract time phrase after 'snooze'
            let timePhrase = input.toLowerCase().replace('snooze', '').trim();
            
            // If the phrase is empty, use default 5 minutes
            if (!timePhrase || timePhrase.length < 2) {
                timePhrase = '5 minutes'; 
            }
            
            const now = new Date();
            const snoozeTime = parseTimePhrase(timePhrase, now);

            if (!snoozeTime) {
                log(`Error: Could not parse snooze time "${timePhrase}". Using default 5 minutes.`);
                // If parsing fails for a complex phrase, try falling back to simple default, then exit.
                const defaultSnooze = parseTimePhrase('5 minutes', now);
                 if (defaultSnooze) {
                    reminder.targetTime = defaultSnooze.getTime();
                    reminder.isAlerting = false;
                    // Reset alert flag so it alerts and logs again when due
                    reminder.hasAlertedOnce = false; 
                    log(`Reminder "${reminder.task}" snoozed. New alert: ${formatTime(defaultSnooze)}. (Used default 5 mins)`);
                    renderReminders();
                }
                return;
            }

            reminder.targetTime = snoozeTime.getTime();
            reminder.isAlerting = false;
            // Reset alert flag so it alerts and logs again when due
            reminder.hasAlertedOnce = false; 
            
            const timeStr = formatTime(snoozeTime);
            log(`Reminder "${reminder.task}" snoozed. New alert: ${timeStr}.`);
            renderReminders();
        }

        function handleDismiss(id) {
            const reminder = reminderList.find(r => r.id === id);
            if (reminder) {
                reminder.isDismissed = true;
                reminder.isAlerting = false;
                log(`Reminder "${reminder.task}" dismissed.`);
                renderReminders();
            }
        }

        function handleDelete(id) {
            const reminder = reminderList.find(r => r.id === id);
            if (reminder) {
                // Instead of deleting, we mark it deleted and filter it out later
                reminder.isDeleted = true;
                reminder.isAlerting = false;
                log(`Reminder "${reminder.task}" permanently deleted.`);
                renderReminders();
            }
        }
        
        // --- Input Handling ---

        function handleInput(rawInput) {
            document.getElementById('commandInput').value = '';
            const input = rawInput.trim();
            if (!input) return;
            
            const normalizedInput = input.toLowerCase();
            const alertingItem = reminderList.find(r => r.isAlerting);

            // 1. --- ALERT HANDLING PRIORITY ---
            if (alertingItem) {
                if (normalizedInput === 'dismiss') {
                    handleDismiss(alertingItem.id);
                    return; 
                }
                
                if (normalizedInput === 'delete') {
                    handleDelete(alertingItem.id);
                    return; 
                }
                
                if (normalizedInput.startsWith('snooze')) {
                    handleSnooze(alertingItem.id, input);
                    return; 
                }
            }
            
            // 2. --- NEW TASK SETTING ---
            handleSetTask(input);
        }

        // --- Rendering ---

        function renderReminders() {
            const container = document.getElementById('reminderListContainer');
            
            // Filter: Only show items that are not deleted
            const visibleReminders = reminderList.filter(r => !r.isDeleted); 

            // Count: Only count items that are NOT dismissed and NOT deleted
            const pendingCount = reminderList.filter(r => !r.isDismissed && !r.isDeleted).length;
            
            container.innerHTML = visibleReminders.map(r => {
                const isPastDue = r.targetTime < Date.now();
                
                let extraClass = '';
                if (r.isAlerting) {
                    extraClass = 'reminder-alerting';
                } else if (r.isDismissed) {
                    extraClass = 'reminder-dismissed';
                }
                
                let timeText;
                let statusColor;

                if (r.isDismissed) {
                    timeText = 'Dismissed';
                    statusColor = 'text-gray-400 font-medium';
                } else if (r.isAlerting) {
                    timeText = 'ALERTING NOW!';
                    statusColor = 'text-red-600 font-bold';
                } else if (isPastDue) {
                    timeText = 'Overdue - Awaiting Action';
                    statusColor = 'text-orange-500';
                } else {
                    timeText = formatTime(new Date(r.targetTime));
                    statusColor = 'text-indigo-600';
                }
                
                return `
                    <div class="reminder-item p-4 flex justify-between items-center ${extraClass}">
                        <div class="flex-grow">
                            <p class="font-semibold text-gray-800">${r.task}</p>
                            <p class="text-sm ${statusColor}">${timeText}</p>
                        </div>
                    </div>
                `;
            }).join('');

            document.getElementById('reminderCount').textContent = pendingCount; // Use the corrected count
        }

        // --- Main Loop and Event Listeners ---

        function checkReminders() {
            const now = Date.now();
            let shouldPlaySound = false;

            reminderList.forEach(r => {
                if (!r.isDismissed && !r.isDeleted && r.targetTime <= now) {
                    // Check if it's due and hasn't logged yet
                    if (!r.hasAlertedOnce) { 
                        r.isAlerting = true;
                        r.hasAlertedOnce = true; // Mark as logged
                        log(`ALERT: "${r.task}" is due! Respond with 'dismiss', 'delete', or 'snooze for [time]'.`);
                    } else if (r.hasAlertedOnce) {
                        // Keep alerting status true for pulsing and sound, but don't log again
                        r.isAlerting = true;
                    }
                }
                
                if (r.isAlerting) {
                    shouldPlaySound = true;
                }
            });

            if (shouldPlaySound) {
                playAlertSound();
            }

            renderReminders();
        }

        document.addEventListener('DOMContentLoaded', () => {
            // Send button handler
            document.getElementById('sendButton').addEventListener('click', () => {
                const input = document.getElementById('commandInput').value;
                handleInput(input);
            });

            // Enter key handler
            document.getElementById('commandInput').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    const input = document.getElementById('commandInput').value;
                    handleInput(input);
                }
            });
            
            // Microphone button (cosmetic) handler
            document.getElementById('micButton').addEventListener('click', () => {
                 log("Vocal input started (type your command).");
                 document.getElementById('micStatus').textContent = 'Listening... Type your command and hit the Pen icon.';
                 // Reset after a short delay to mimic a recording timeout
                 setTimeout(() => {
                    document.getElementById('micStatus').textContent = 'Click to mimic starting a vocal input (Type commands below).';
                 }, 3000);
            });


            // Start the check loop
            setInterval(checkReminders, 1000);
        });
    </script>
</body>
</html>
