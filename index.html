<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vocal Reminder App</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            min-height: 100vh;
            background-color: #f7f9fc;
        }
        .mic-button {
            transition: all 0.2s ease;
        }
        .mic-button:hover {
            transform: scale(1.05);
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
        }
        .listening {
            animation: pulse-ring 1.5s infinite;
        }
        @keyframes pulse-ring {
            0% { box-shadow: 0 0 0 0 rgba(76, 29, 149, 0.4); }
            70% { box-shadow: 0 0 0 20px rgba(76, 29, 149, 0); }
            100% { box-shadow: 0 0 0 0 rgba(76, 29, 149, 0); }
        }
        .alarm-active {
            animation: alarm-shake 0.5s infinite;
            border-color: #ef4444 !important;
        }
        @keyframes alarm-shake {
            0%, 100% { transform: translateX(0); }
            20%, 60% { transform: translateX(-5px); }
            40%, 80% { transform: translateX(5px); }
        }
        .countdown-time {
            /* Ensure the countdown is easily visible */
            font-weight: 600;
            color: #4f46e5; /* Indigo-600 */
        }
    </style>
</head>
<body class="p-4 md:p-8 flex flex-col items-center">

    <div id="app-container" class="w-full max-w-lg bg-white p-6 md:p-8 rounded-xl shadow-2xl transition-all duration-500 border-4 border-indigo-100">

        <h1 class="text-3xl font-bold text-gray-800 mb-2 text-center">Vocal Reminders</h1>
        <p class="text-center text-sm text-gray-500 mb-6">Your voice-activated personal assistant.</p>
        
        <!-- User ID Display -->
        <div id="user-id-display" class="text-xs text-gray-400 text-center mb-4 truncate" title="Your User ID">
            Loading authentication...
        </div>

        <!-- Status Display -->
        <div id="status-box" class="p-4 rounded-lg text-center font-medium bg-indigo-50 text-indigo-700 mb-6 border border-indigo-200 min-h-[5rem] flex items-center justify-center">
            Click the microphone and say "Set a reminder for [task] on [date] at [time]" or "in [duration]".
        </div>

        <!-- Microphone Button -->
        <div class="flex justify-center mb-6">
            <button id="mic-btn" class="mic-button p-6 rounded-full bg-indigo-600 text-white shadow-xl hover:bg-indigo-700 focus:outline-none focus:ring-4 focus:ring-indigo-300 transition-all duration-200">
                <!-- Simple Microphone Icon -->
                <svg xmlns="http://www.w3.org/2000/svg" class="h-10 w-10" viewBox="0 0 20 20" fill="currentColor">
                    <path d="M7 4a3 3 0 016 0v4a3 3 0 11-6 0V4z" />
                    <path fill-rule="evenodd" d="M3 8a1 1 0 011 1v3.5A6.5 6.5 0 0017 12.5V9a1 1 0 112 0v3.5a8.5 8.5 0 01-17 0V9a1 1 0 011-1z" clip-rule="evenodd" />
                </svg>
            </button>
        </div>
        
        <!-- Manual Input Box -->
        <div class="mb-8 p-4 bg-gray-50 rounded-xl shadow-inner border border-gray-200">
            <label for="reminder-input" class="block text-sm font-medium text-gray-700 mb-2">Or, Type Your Reminder or Command:</label>
            <div class="flex space-x-2">
                <input 
                    type="text" 
                    id="reminder-input" 
                    class="flex-grow p-3 border border-gray-300 rounded-lg focus:ring-indigo-500 focus:border-indigo-500 text-base shadow-sm"
                    placeholder='e.g., "Call Mom on Dec 25 at 11:30am", "snooze 5m", or "dismiss"'
                >
                <button 
                    id="set-manual-btn"
                    class="px-3 py-3 bg-indigo-500 text-white font-semibold rounded-lg shadow-md hover:bg-indigo-600 transition-colors flex-shrink-0 flex items-center justify-center"
                    title="Set Reminder"
                >
                    <!-- Document Plus Icon: Represents setting/adding a new reminder (writing a note) -->
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" class="w-5 h-5">
                        <path fill-rule="evenodd" d="M4 2a2 2 0 00-2 2v12a2 2 0 002 2h8a2 2 0 002-2V7.757a2 2 0 00-.586-1.414L9.757 2.586A2 2 0 008.343 2H4zm6 6.5a.75.75 0 00-1.5 0v1.5H7.5a.75.75 0 000 1.5h1.5v1.5a.75.75 0 001.5 0v-1.5h1.5a.75.75 0 000-1.5h-1.5v-1.5z" clip-rule="evenodd" />
                    </svg>
                </button>
            </div>
        </div>


        <!-- Reminders List -->
        <h2 class="text-xl font-semibold text-gray-700 mb-4 border-b pb-2">Active Reminders</h2>
        <ul id="reminders-list" class="space-y-3">
            <li class="text-gray-500 italic p-3">Loading reminders...</li>
        </ul>
    </div>

    <script type="module">
        // Firebase and User Configuration Globals
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : { apiKey: "AIza-placeholder-key", authDomain: "placeholder.firebaseapp.com", projectId: "placeholder" };
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

        // Firebase Imports
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, collection, onSnapshot, setDoc, deleteDoc, doc, Timestamp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        // import { setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        // setLogLevel('debug'); // Uncomment for debugging

        // Initialize Firebase services outside the function to avoid redeclaration error
        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);
        const auth = getAuth(app);


        // Global state for app data and user info
        let userId = null;
        let isAuthReady = false;
        let reminders = [];
        let activeAlarm = null;
        let recognition = null;
        let alarmIntervalId = null;
        let audioContext = null;

        // --- Core Application State & Constants ---
        const $ = (id) => document.getElementById(id);
        const STATUS_BOX = $('status-box');
        const MIC_BTN = $('mic-btn');
        const APP_CONTAINER = $('app-container');
        const REMINDERS_LIST = $('reminders-list');
        const REMINDER_INPUT = $('reminder-input');
        const SET_MANUAL_BTN = $('set-manual-btn');
        const USER_ID_DISPLAY = $('user-id-display');

        const MONTH_MAP = {
            'january': 0, 'jan': 0, 'february': 1, 'feb': 1, 'march': 2, 'mar': 2, 
            'april': 3, 'apr': 3, 'may': 4, 'june': 5, 'jun': 5, 'july': 6, 'jul': 6, 
            'august': 7, 'aug': 7, 'september': 8, 'sep': 8, 'october': 9, 'oct': 9, 
            'november': 10, 'nov': 10, 'december': 11, 'dec': 11
        };

        // --- Utility Functions ---

        /** Sets the status message and speaks it if necessary. */
        function setStatus(message, speak = false) {
            console.log("Status: " + message);
            STATUS_BOX.textContent = message;
            if (speak) {
                speakText(message);
            }
        }

        /** Text-to-Speech function. */
        function speakText(text) {
            if ('speechSynthesis' in window) {
                window.speechSynthesis.cancel();
                const utterance = new SpeechSynthesisUtterance(text);
                utterance.voice = window.speechSynthesis.getVoices().find(voice => voice.name.includes('Google US English')) || window.speechSynthesis.getVoices()[0];
                utterance.rate = 1.1;
                window.speechSynthesis.speak(utterance);
            } else {
                console.warn('Speech Synthesis not supported.');
            }
        }

        /** Parses a complex time phrase (relative or absolute) into a Date object. */
        function parseReminderTime(phrase) {
            phrase = phrase.trim().toLowerCase();
            const now = new Date();
            let futureTime = new Date(now.getTime());

            // --- 1. RELATIVE TIME PARSING (e.g., "in 5 minutes", "in 3 hours") ---
            const relativeMatch = phrase.match(/(?:in|after) (\d+|a|an|one) (minutes?|hours?|seconds?|min|sec|hr|day|week|month|year)s?/i);
            
            if (relativeMatch) {
                let value = parseInt(relativeMatch[1]);
                if (isNaN(value)) {
                    value = (relativeMatch[1].toLowerCase() === 'one' || relativeMatch[1].toLowerCase() === 'a' || relativeMatch[1].toLowerCase() === 'an') ? 1 : 0;
                }
                const unit = relativeMatch[2].toLowerCase();

                if (unit.startsWith('minute') || unit === 'min') {
                    futureTime.setMinutes(futureTime.getMinutes() + value);
                } else if (unit.startsWith('hour') || unit === 'hr') {
                    futureTime.setHours(futureTime.getHours() + value);
                } else if (unit.startsWith('second') || unit === 'sec') {
                    futureTime.setSeconds(futureTime.getSeconds() + value);
                } else if (unit.startsWith('day')) {
                    futureTime.setDate(futureTime.getDate() + value);
                } else if (unit.startsWith('week')) {
                    futureTime.setDate(futureTime.getDate() + (value * 7));
                } else if (unit.startsWith('month')) {
                    futureTime.setMonth(futureTime.getMonth() + value);
                } else if (unit.startsWith('year')) {
                    futureTime.setFullYear(futureTime.getFullYear() + value);
                }
                return futureTime;
            }

            // --- 2. ABSOLUTE DATE/TIME PARSING (e.g., "October 25 at 11am") ---
            // Regex captures: [Month Name/Abbr] [Day] (optional: at [Hour:Minute] [AM/PM])
            const absoluteMatch = phrase.match(/([a-z]+) (\d{1,2})(?: at (\d{1,2})(?::(\d{1,2}))? ?(am|pm)?)?/i);

            if (absoluteMatch) {
                const monthStr = absoluteMatch[1];
                const day = parseInt(absoluteMatch[2]);
                let hour = parseInt(absoluteMatch[3] || '0');
                let minute = parseInt(absoluteMatch[4] || '0');
                const ampm = absoluteMatch[5] ? absoluteMatch[5].toLowerCase() : null;

                const month = MONTH_MAP[monthStr];
                if (month === undefined || isNaN(day) || day < 1 || day > 31) {
                    setStatus('I found a date but the month or day is invalid.', true);
                    return null;
                }

                // Initialize to the correct year
                futureTime.setFullYear(now.getFullYear(), month, day);

                // Adjust for 12/24 hour time
                if (ampm === 'pm' && hour < 12) {
                    hour += 12;
                } else if (ampm === 'am' && hour === 12) {
                    hour = 0; // Midnight 12 AM is 0 hour
                }
                
                // Set the time
                futureTime.setHours(hour, minute, 0, 0);

                // Handle Year Rollover: If the set date/time is in the past, push it to next year.
                // We only do this check if the time is not today or in the future
                if (futureTime.getTime() < now.getTime()) {
                    // Check if it's because the current time of day is past the specified time
                    // Or if the date itself is in the past
                    const originalYear = futureTime.getFullYear();
                    futureTime.setFullYear(originalYear + 1);
                    setStatus(`Setting reminder for next year (${futureTime.getFullYear()}) as the specified date has passed this year.`, false);
                }

                return futureTime;
            }

            // --- 3. PARSING FAILED ---
            setStatus('I could not parse the date or duration. Try "October 25 at 11am" or "in 5 minutes".', true);
            return null;
        }


        /** Parses a snooze duration phrase into milliseconds. */
        function parseDuration(phrase) {
            phrase = phrase.trim().toLowerCase();
            const timeMatch = phrase.match(/(\d+|a|an|one) (minutes?|hours?|seconds?|min|sec|hr)/i);
            
            if (timeMatch) {
                let value = parseInt(timeMatch[1]);
                if (isNaN(value)) {
                    value = (timeMatch[1].toLowerCase() === 'one' || timeMatch[1].toLowerCase() === 'a' || timeMatch[1].toLowerCase() === 'an') ? 1 : 0;
                }
                const unit = timeMatch[2].toLowerCase();

                if (unit.startsWith('minute') || unit === 'min') {
                    return value * 60 * 1000;
                } else if (unit.startsWith('hour') || unit === 'hr') {
                    return value * 3600 * 1000;
                } else if (unit.startsWith('second') || unit === 'sec') {
                    return value * 1000;
                }
            } 
            
            const secondsMatch = phrase.match(/^(\d+)$/);
            if (secondsMatch) {
                const seconds = parseInt(secondsMatch[1]);
                if (seconds > 7200) {
                     setStatus("Snooze time must be less than 2 hours.", true);
                     return null;
                }
                return seconds * 1000;
            }

            return null;
        }

        /** Formats milliseconds into a human-readable Hh M:SS string. */
        function formatTimeDifference(ms) {
            if (ms < 0) return "DUE NOW!";
            
            let seconds = Math.floor(ms / 1000);
            const hours = Math.floor(seconds / 3600);
            seconds %= 3600;
            const minutes = Math.floor(seconds / 60);
            seconds %= 60;

            const pad = (num) => String(num).padStart(2, '0');

            if (hours > 0) {
                return `${hours}h ${pad(minutes)}m ${pad(seconds)}s`;
            } else if (minutes > 0) {
                return `${minutes}m ${pad(seconds)}s`;
            } else {
                return `${seconds}s`;
            }
        }

        // --- Firebase Data Interaction ---

        /** Gets the reference to the user's reminders collection. */
        function getRemindersCollectionRef() {
            if (!userId) return null;
            // Private data storage path: /artifacts/{appId}/users/{userId}/reminders
            return collection(db, 'artifacts', appId, 'users', userId, 'reminders');
        }

        /** Adds a new reminder to Firestore. */
        async function addReminder(text, time) {
            if (!isAuthReady) {
                setStatus("System loading, please wait a moment.", true);
                return;
            }
            try {
                const docId = crypto.randomUUID(); // Use UUID for document ID
                await setDoc(doc(getRemindersCollectionRef(), docId), {
                    text: text,
                    time: Timestamp.fromDate(time), // Convert Date to Firestore Timestamp
                    createdAt: Timestamp.now(),
                    isActive: false, // Local UI state, but useful for persistence checks
                    docId: docId // Store docId within the document for easy reference
                });

                const timeOptions = { weekday: 'short', year: 'numeric', month: 'short', day: 'numeric', hour: '2-digit', minute: '2-digit' };
                setStatus(`Reminder set for "${text}" on ${time.toLocaleDateString('en-US', timeOptions)}.`, true);
            } catch (error) {
                console.error("Error setting reminder:", error);
                setStatus("Failed to set reminder due to a database error.", true);
            }
        }

        /** Clears a reminder by its Firestore document ID. */
        async function clearReminder(docId) {
            if (!isAuthReady) {
                setStatus("System loading, please wait a moment.", true);
                return false;
            }
            try {
                // Find the reminder locally to check if it's the active alarm
                const reminder = reminders.find(r => r.docId === docId);

                await deleteDoc(doc(getRemindersCollectionRef(), docId));
                
                setStatus("The reminder has been dismissed.", true);

                if (activeAlarm && activeAlarm.docId === docId) {
                    stopAlarm();
                }
                // The renderReminders will be triggered by onSnapshot
                return true;
            } catch (error) {
                console.error("Error deleting reminder:", error);
                setStatus("Failed to dismiss reminder due to a database error.", true);
                return false;
            }
        }

        /** Snoozes the current active alarm for a specified duration in milliseconds by updating the time in Firestore. */
        async function snoozeAlarm(durationMs = 5 * 60 * 1000) {
            if (!activeAlarm || !isAuthReady) {
                setStatus("There is no active alarm to snooze.", true);
                return;
            }
            
            const docId = activeAlarm.docId;
            const newTime = new Date(Date.now() + durationMs);

            try {
                // Update the document in Firestore
                await setDoc(doc(getRemindersCollectionRef(), docId), {
                    time: Timestamp.fromDate(newTime),
                    isActive: false // Deactivate locally until next trigger
                }, { merge: true });

                let displayDuration;
                if (durationMs < 60000) {
                    displayDuration = `${durationMs / 1000} seconds`;
                } else if (durationMs < 3600000) {
                    const minutes = Math.floor(durationMs / 60000);
                    const seconds = Math.floor((durationMs % 60000) / 1000);
                    displayDuration = `${minutes} minute${minutes !== 1 ? 's' : ''}`;
                    if (seconds > 0) displayDuration += ` and ${seconds} second${seconds !== 1 ? 's' : ''}`;
                } else {
                    displayDuration = `${durationMs / 3600000} hours`;
                }

                setStatus(`Alarm snoozed for ${displayDuration}. New time is ${newTime.toLocaleTimeString()}.`, true);
                stopAlarm();
                // onSnapshot will handle the state update and re-render
            } catch (error) {
                console.error("Error snoozing alarm:", error);
                setStatus("Failed to snooze alarm due to a database error.", true);
            }
        }

        // --- Reminder Logic (Local) ---

        /** Triggers the alarm sequence for a reminder. */
        function triggerAlarm(reminder) {
            if (activeAlarm) return;

            activeAlarm = reminder;
            APP_CONTAINER.classList.add('alarm-active');
            setStatus(`ALARM: Time for "${reminder.text}"! Say or type "Snooze" or "Dismiss."`, true);

            playAlarmSound();
            // Note: We don't save isActive state to Firestore unless snoozing/clearing
            reminder.isActive = true; 
            renderReminders();
        }

        /** Stops the current alarm. */
        function stopAlarm() {
            if (activeAlarm) {
                stopAlarmSound();
                // Find the reminder in the array and set its local state to false
                const localReminder = reminders.find(r => r.docId === activeAlarm.docId);
                if (localReminder) {
                    localReminder.isActive = false;
                }
                activeAlarm = null;
                APP_CONTAINER.classList.remove('alarm-active');
                renderReminders();
            }
        }

        /** Plays a simple beeping sound using AudioContext. */
        function playAlarmSound() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }
            if (alarmIntervalId) clearInterval(alarmIntervalId);

            let isPlaying = false;

            const beep = () => {
                if (isPlaying) return;
                isPlaying = true;
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();

                oscillator.type = 'square';
                oscillator.frequency.setValueAtTime(880, audioContext.currentTime);
                gainNode.gain.setValueAtTime(0.5, audioContext.currentTime);

                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);

                oscillator.start();
                
                gainNode.gain.exponentialRampToValueAtTime(0.00001, audioContext.currentTime + 0.2);
                oscillator.stop(audioContext.currentTime + 0.2);
                setTimeout(() => { isPlaying = false; }, 200);
            };

            beep();
            alarmIntervalId = setInterval(beep, 700);
        }

        /** Stops the simple alarm sound. */
        function stopAlarmSound() {
            if (alarmIntervalId) {
                clearInterval(alarmIntervalId);
                alarmIntervalId = null;
            }
        }

        /** Loop to check if any reminders are due. */
        function checkReminders() {
            const now = new Date();
            for (let reminder of reminders) {
                // If it's not currently the active alarm, and the time has passed
                if (!activeAlarm && reminder.time.getTime() <= now.getTime()) {
                    triggerAlarm(reminder);
                }
            }
        }
        
        /** Updates the countdown display for all reminders. */
        function updateCountdowns() {
            const now = Date.now();
            for (const reminder of reminders) {
                const countdownElement = $(`countdown-${reminder.docId}`);
                
                if (countdownElement) {
                    if (!reminder.isActive) { 
                        const diff = reminder.time.getTime() - now;
                        countdownElement.textContent = formatTimeDifference(diff);
                        
                        if (diff < 60000 && diff > 0) { // Less than 1 minute (but not yet due)
                            countdownElement.classList.remove('text-indigo-500');
                            countdownElement.classList.add('text-orange-500');
                        } else {
                            countdownElement.classList.remove('text-orange-500');
                            countdownElement.classList.add('text-indigo-500');
                        }

                    } else {
                        countdownElement.textContent = "ALARM RINGING";
                    }
                }
            }
        }

        /** Main loop to check alarms and update the display. */
        function mainLoop() {
            checkReminders(); 
            updateCountdowns();
        }
        
        // --- UI Action Handlers ---

        /** Handles deletion triggered by the UI button (using Firestore ID). */
        function deleteReminderUI(docId) {
            setStatus("Deleting reminder.", true);
            clearReminder(docId);
        }
        
        // Expose to global scope for use in onclick handlers in the dynamically generated HTML
        window.deleteReminderUI = deleteReminderUI;


        /** Handles setting a reminder via the manual text input, including snooze/dismiss commands. */
        function handleManualSet() {
            const input = REMINDER_INPUT.value.trim();
            const lowerInput = input.toLowerCase();

            if (!input) {
                setStatus("Please enter a reminder phrase or command in the box.", true);
                return;
            }

            // 1. Snooze Command
            if (lowerInput.startsWith('snooze')) {
                let durationMs = 5 * 60 * 1000;
                const durationPhrase = input.substring('snooze'.length).trim();
                
                if (durationPhrase.length > 0) {
                    const parsedDuration = parseDuration(durationPhrase);

                    if (parsedDuration !== null && parsedDuration > 0) {
                        durationMs = parsedDuration;
                    } else if (durationPhrase !== "") {
                        setStatus("Snooze command recognized, but I could not parse the duration. Using default 5 minutes.", true);
                    }
                }
                
                snoozeAlarm(durationMs);
                REMINDER_INPUT.value = '';
                return;
            }
            
            // 2. Dismiss Command
            if (lowerInput === 'dismiss') {
                if (activeAlarm) {
                    clearReminder(activeAlarm.docId); 
                    REMINDER_INPUT.value = '';
                    return;
                } else {
                    setStatus("There is no active alarm to dismiss.", true);
                    REMINDER_INPUT.value = '';
                    return;
                }
            }

            // 3. Process as a new Reminder (allowing for a wide range of time phrases)
            // Regex captures: [TASK] (on/in/at) [TIME PHRASE]
            const manualMatch = input.match(/(.+?) (?:at|in|on) (.+)/i);

            if (manualMatch && manualMatch.length === 3) {
                const text = manualMatch[1].trim();
                const timePhrase = manualMatch[2].trim();
                const time = parseReminderTime(timePhrase);
                
                if (time) {
                    addReminder(text, time);
                    REMINDER_INPUT.value = '';
                }
            } else {
                setStatus("I couldn't parse that. Please use 'Task on [date] at [time]' or 'Task in [duration]'.", true);
            }
        }


        // --- UI Rendering ---

        function renderReminders() {
            if (reminders.length === 0) {
                REMINDERS_LIST.innerHTML = '<li class="text-gray-500 italic p-3">No reminders set.</li>';
                return;
            }

            reminders = reminders
                .map(r => ({ ...r, time: new Date(r.time) })) // Ensure all times are Date objects
                .sort((a, b) => a.time.getTime() - b.time.getTime());

            REMINDERS_LIST.innerHTML = reminders
                .map(r => {
                    // Check if this is the currently ringing alarm
                    const isActiveAlarm = activeAlarm && activeAlarm.docId === r.docId;
                    const statusClass = isActiveAlarm ? 'bg-red-100 text-red-800 border-red-400' : 'bg-white text-gray-800 border-gray-200';
                    const timeOptions = { month: 'short', day: 'numeric', hour: '2-digit', minute: '2-digit' };
                    const timeString = r.time.toLocaleDateString('en-US', timeOptions);

                    return `
                        <li class="p-3 rounded-lg flex justify-between items-center shadow-md transition-shadow border-2 ${statusClass}">
                            <div class="flex flex-col flex-grow min-w-0 pr-4">
                                <span class="text-base font-semibold truncate">${r.text}</span>
                                <span id="countdown-${r.docId}" class="text-sm font-mono countdown-time mt-1">Calculating...</span>
                            </div>
                            <div class="flex items-center space-x-3 flex-shrink-0">
                                <!-- Original set time and date for reference -->
                                <span class="text-xs text-gray-500 hidden sm:inline">@ ${timeString}</span>
                                <button 
                                    class="text-red-500 hover:text-red-700 p-1 rounded-full hover:bg-red-100 transition-colors"
                                    onclick="deleteReminderUI('${r.docId}')"
                                    title="Delete Reminder"
                                >
                                    <!-- Trash Icon -->
                                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                                      <path fill-rule="evenodd" d="M9 2a1 1 0 00-.894.553L7.382 4H4a1 1 0 000 2v10a2 2 0 002 2h8a2 2 0 002-2V6a1 1 0 100-2h-3.382l-.724-1.447A1 1 0 0011 2H9zM7 8a1 1 0 012 0v6a1 1 0 11-2 0V8zm4 0a1 1 0 10-2 0v6a1 1 0 102 0V8z" clip-rule="evenodd" />
                                    </svg>
                                </button>
                            </div>
                        </li>
                    `;
                })
                .join('');
             updateCountdowns();
        }

        // --- Speech Recognition Setup & Handler ---

        function setupSpeechRecognition() {
            if (!('webkitSpeechRecognition' in window)) {
                STATUS_BOX.textContent = "Speech Recognition not supported in this browser.";
                MIC_BTN.disabled = true;
                return;
            }

            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            recognition = new SpeechRecognition();
            recognition.continuous = false;
            recognition.lang = 'en-US';
            recognition.interimResults = false;

            recognition.onstart = () => {
                MIC_BTN.classList.add('listening');
                setStatus("Listening... Speak your command now.");
            };

            recognition.onresult = (event) => {
                const transcript = event.results[0][0].transcript;
                MIC_BTN.classList.remove('listening');
                handleVoiceCommand(transcript);
            };

            recognition.onerror = (event) => {
                MIC_BTN.classList.remove('listening');
                if (event.error === 'not-allowed') {
                    setStatus("Microphone permission denied.", true);
                } else if (event.error === 'no-speech') {
                     setStatus("No speech detected. Please try again.", true);
                } else {
                    setStatus(`Speech recognition error: ${event.error}`, true);
                }
            };

            recognition.onend = () => {
                MIC_BTN.classList.remove('listening');
            };

            MIC_BTN.onclick = () => {
                if (MIC_BTN.classList.contains('listening')) {
                    recognition.stop();
                } else {
                    recognition.start();
                }
            };
        }
        
        function handleVoiceCommand(transcript) {
            const lowerTranscript = transcript.toLowerCase();
            
            // 1. Snooze/Dismiss when Alarm is Active
            if (activeAlarm) {
                if (lowerTranscript.includes('snooze')) {
                    const snoozeMatch = lowerTranscript.match(/snooze for (.+)/) || lowerTranscript.match(/snooze (.+)/);
                    let durationMs = 5 * 60 * 1000;
                    if (snoozeMatch) {
                        const parsedDuration = parseDuration(snoozeMatch[1]);
                        if (parsedDuration !== null && parsedDuration > 0) {
                            durationMs = parsedDuration;
                        }
                    }
                    snoozeAlarm(durationMs);
                    return;
                } else if (lowerTranscript.includes('dismiss') || lowerTranscript.includes('clear')) {
                    clearReminder(activeAlarm.docId);
                    return;
                }
            }
            
            // 2. Set New Reminder (Voice Command)
            // Tries to match: "set a reminder for [task] (on|in|at) [time phrase]"
            const match = lowerTranscript.match(/set a reminder for (.+?) (?:on|in|at) (.+)/);
            
            if (match && match.length === 3) {
                const text = match[1].trim();
                const timePhrase = match[2].trim();
                const time = parseReminderTime(timePhrase);
                
                if (time) {
                    addReminder(text, time);
                }
                return;
            }

            // 3. Fallback for Unmatched Commands
            setStatus(`I heard "${transcript}" but I couldn't understand that command. Please try "Set a reminder for [task] on October 25 at 11am."`, true);
        }

        // --- Initialization ---

        async function initializeAuthAndData() {
            // 1. Authenticate using onAuthStateChanged to ensure the user object is properly loaded
            onAuthStateChanged(auth, async (user) => {
                if (!user) {
                    // Only attempt sign-in if the user is not yet loaded (initial state)
                    if (initialAuthToken) {
                        await signInWithCustomToken(auth, initialAuthToken).catch(e => {
                            console.error("Custom token sign-in failed, falling back to anonymous.", e);
                            signInAnonymously(auth);
                        });
                    } else {
                        await signInAnonymously(auth);
                    }
                }
                
                // Once the state is finalized (either new sign-in or existing user)
                if (auth.currentUser) {
                    userId = auth.currentUser.uid;
                    USER_ID_DISPLAY.textContent = `User ID: ${userId}`;
                    isAuthReady = true;

                    // 2. Start Real-time Listener (after successful authentication)
                    const remindersColRef = getRemindersCollectionRef();
                    if (remindersColRef) {
                        onSnapshot(remindersColRef, (snapshot) => {
                            const newReminders = [];
                            snapshot.forEach(doc => {
                                const data = doc.data();
                                newReminders.push({
                                    docId: doc.id,
                                    text: data.text,
                                    // Convert Firestore Timestamp back to JavaScript Date object
                                    time: data.time.toDate(),
                                    isActive: activeAlarm && activeAlarm.docId === doc.id ? true : false, // Maintain local active state
                                });
                            });
                            reminders = newReminders;
                            renderReminders();
                            
                            // If no active alarm and we have reminders, ensure we check them immediately
                            if (!activeAlarm && reminders.length > 0) {
                                checkReminders();
                            }
                        }, (error) => {
                            console.error("Firestore snapshot error:", error);
                            setStatus("Error loading reminders. Check console for details.", true);
                        });
                    }
                } else {
                    setStatus("Could not authenticate. Reminders will not be saved.", true);
                }
            });

            // 3. Setup UI and Loops
            SET_MANUAL_BTN.onclick = handleManualSet;
            REMINDER_INPUT.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    handleManualSet();
                }
            });

            // Start the periodic check and UI refresh loop
            setInterval(mainLoop, 1000); 

            if ('speechSynthesis' in window) {
                window.speechSynthesis.getVoices();
            }
            setupSpeechRecognition();
            setStatus("Welcome! Click the microphone or type below to set reminders, including specific dates.");
            renderReminders();
        }

        // Start the application initialization
        initializeAuthAndData();

    </script>
</body>
</html>
