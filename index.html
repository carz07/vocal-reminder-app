<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vocal Reminder App</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <!-- Font Awesome for icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            min-height: 100vh;
            background-color: #f7f9fc;
        }
        .mic-button {
            transition: all 0.2s ease;
        }
        .mic-button:hover {
            transform: scale(1.05);
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
        }
        .listening {
            animation: pulse-ring 1.5s infinite;
        }
        @keyframes pulse-ring {
            0% { box-shadow: 0 0 0 0 rgba(76, 29, 149, 0.4); }
            70% { box-shadow: 0 0 0 10px rgba(76, 29, 149, 0); }
            100% { box-shadow: 0 0 0 0 rgba(76, 29, 149, 0); }
        }
        .text-input-group {
            position: relative;
        }
        .pen-button {
            transition: transform 0.1s ease;
        }
        .pen-button:active {
            transform: scale(0.95);
        }
    </style>
</head>
<body class="p-4 sm:p-8 flex flex-col items-center">

    <!-- Main Container -->
    <div class="w-full max-w-xl">

        <h1 class="text-3xl font-bold text-gray-800 text-center mb-6">Vocal Reminder</h1>
        
        <!-- Status Message Area -->
        <div id="status-message" class="p-3 text-sm text-center rounded-lg mb-6 transition-all duration-300 min-h-[40px] flex items-center justify-center bg-blue-100 text-blue-800 border border-blue-200">
            Welcome! Click the microphone or type below to set reminders.
        </div>

        <!-- Microphone Input Area -->
        <div class="flex flex-col items-center space-y-4 mb-8">
            <button id="mic-button" class="mic-button w-24 h-24 rounded-full bg-indigo-600 text-white flex items-center justify-center shadow-lg transition duration-150 ease-in-out">
                <i class="fas fa-microphone text-3xl"></i>
            </button>
            <p id="mic-status" class="text-sm text-gray-500 font-medium">Click to Speak</p>
        </div>

        <!-- Manual Text Input -->
        <div class="text-input-group flex space-x-2">
            <input type="text" id="reminder-input" placeholder='e.g., "Drink water in 5 seconds"' class="flex-grow p-3 border border-gray-300 rounded-lg focus:ring-indigo-500 focus:border-indigo-500 shadow-sm transition duration-150 ease-in-out" />
            <button id="set-manual-btn" class="pen-button p-3 bg-white text-indigo-600 border border-gray-300 rounded-lg shadow-sm hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-indigo-500">
                <i class="fas fa-pen text-xl"></i>
            </button>
        </div>
        <p class="text-xs text-gray-400 mt-2 text-center">Use format: [Task] [on/in/at] [Time Phrase]</p>

        <hr class="my-8 border-gray-200">

        <!-- Reminder List -->
        <h2 class="text-2xl font-semibold text-gray-800 mb-4">Upcoming Reminders</h2>
        <div id="reminders-list" class="space-y-3">
            <!-- Reminders will be injected here -->
            <p id="no-reminders" class="text-center text-gray-500 p-4 bg-white rounded-lg shadow-md">No reminders set yet.</p>
        </div>
    </div>

    <!-- Alarm Modal -->
    <div id="alarm-modal" class="fixed inset-0 bg-black bg-opacity-70 hidden items-center justify-center p-4 z-50 transition-opacity duration-300">
        <div class="bg-white p-6 sm:p-8 rounded-xl shadow-2xl max-w-sm w-full text-center transform transition-all duration-300 scale-95 opacity-0" id="modal-content">
            <div class="flex justify-center mb-4">
                <i class="fas fa-bell text-5xl text-red-500 animate-pulse"></i>
            </div>
            <h3 class="text-xl font-bold text-gray-800 mb-2">TIME TO REMEMBER!</h3>
            <p id="alarm-text" class="text-lg text-gray-600 mb-6 font-medium break-words"></p>

            <!-- Snooze Options -->
            <div class="mb-4">
                <select id="snooze-duration" class="w-full p-2 border border-gray-300 rounded-lg text-gray-700">
                    <option value="5">5 Seconds (Testing)</option>
                    <option value="30">30 Minutes</option>
                    <option value="60">1 Hour</option>
                    <option value="1440">1 Day</option>
                </select>
            </div>

            <div class="flex justify-center space-x-3">
                <button id="snooze-btn" class="px-4 py-2 bg-yellow-500 text-white font-semibold rounded-lg shadow-md hover:bg-yellow-600 transition duration-150">
                    Snooze
                </button>
                <button id="dismiss-btn" class="px-4 py-2 bg-indigo-600 text-white font-semibold rounded-lg shadow-md hover:bg-indigo-700 transition duration-150">
                    Dismiss
                </button>
            </div>
        </div>
    </div>

    <script>
        // --- GLOBAL SETUP (NO FIREBASE) ---

        const STORAGE_KEY = 'vocalReminders';
        let reminders = [];
        let recognition = null; // Speech Recognition API instance

        // --- DOM Elements ---
        const STATUS_MESSAGE = document.getElementById('status-message');
        const REMINDERS_LIST = document.getElementById('reminders-list');
        const ALARM_MODAL = document.getElementById('alarm-modal');
        const MODAL_CONTENT = document.getElementById('modal-content');
        const ALARM_TEXT = document.getElementById('alarm-text');
        const SNOOZE_BTN = document.getElementById('snooze-btn');
        const DISMISS_BTN = document.getElementById('dismiss-btn');
        const SNOOZE_DURATION_SELECT = document.getElementById('snooze-duration');
        const REMINDER_INPUT = document.getElementById('reminder-input');
        const SET_MANUAL_BTN = document.getElementById('set-manual-btn');
        const MIC_BUTTON = document.getElementById('mic-button');
        const MIC_STATUS = document.getElementById('mic-status');

        // --- Utility Functions ---

        /**
         * Formats a timestamp into a human-readable date and time string.
         * @param {number} timestamp
         * @returns {string} Formatted time string
         */
        const formatTime = (timestamp) => {
            const date = new Date(timestamp);
            return date.toLocaleString([], {
                year: 'numeric',
                month: 'short',
                day: 'numeric',
                hour: '2-digit',
                minute: '2-digit'
            });
        };

        /**
         * Displays a status message to the user.
         * @param {string} message The message to display.
         * @param {boolean} isError If true, displays as an error.
         */
        const setStatus = (message, isError) => {
            STATUS_MESSAGE.textContent = message;
            STATUS_MESSAGE.className = 'p-3 text-sm text-center rounded-lg mb-6 transition-all duration-300 min-h-[40px] flex items-center justify-center';
            if (isError) {
                STATUS_MESSAGE.classList.add('bg-red-100', 'text-red-800', 'border', 'border-red-200');
            } else {
                STATUS_MESSAGE.classList.add('bg-blue-100', 'text-blue-800', 'border', 'border-blue-200');
            }
        };

        // --- Local Storage CRUD ---

        /**
         * Loads reminders from local storage.
         */
        const loadReminders = () => {
            try {
                const stored = localStorage.getItem(STORAGE_KEY);
                reminders = stored ? JSON.parse(stored) : [];
                // Ensure reminders are sorted by timestamp for display
                reminders.sort((a, b) => a.timestamp - b.timestamp); 
                renderReminders();
            } catch (e) {
                console.error("Error loading from local storage:", e);
                setStatus("Error loading previous reminders.", true);
                reminders = [];
            }
        };

        /**
         * Saves the current reminder array to local storage.
         */
        const saveReminders = () => {
            try {
                localStorage.setItem(STORAGE_KEY, JSON.stringify(reminders));
                renderReminders();
            } catch (e) {
                console.error("Error saving to local storage:", e);
                setStatus("Error saving reminders.", true);
            }
        };

        /**
         * Adds a new reminder to the local array and saves.
         * @param {string} text Reminder text.
         * @param {number} timestamp Target timestamp in milliseconds.
         */
        const addReminder = (text, timestamp) => {
            const newId = Date.now().toString() + Math.random().toString(36).substring(2, 9);
            reminders.push({
                id: newId,
                text: text,
                timestamp: timestamp,
                createdAt: Date.now()
            });
            reminders.sort((a, b) => a.timestamp - b.timestamp);
            saveReminders();
            setStatus(`Reminder set for: ${formatTime(timestamp)}`, false);
        };

        /**
         * Deletes a reminder from the local array and saves.
         * @param {string} id Unique ID of the reminder to delete.
         */
        const deleteReminder = (id) => {
            reminders = reminders.filter(r => r.id !== id);
            saveReminders();
        };


        // --- Core Logic: Time Parsing ---

        /**
         * Parses a natural language time phrase into a future UTC timestamp.
         * @param {string} phrase The time phrase (e.g., "5 seconds", "October 25 at 4:30 PM").
         * @returns {number | null} Future UTC timestamp in milliseconds, or null if parsing fails.
         */
        const parseReminderTime = (phrase) => {
            const lowerPhrase = phrase.toLowerCase().trim();
            const now = new Date();
            let targetTime = null;

            // 1. Relative Time Parsing (e.g., "5 seconds", "2 hours", "3 days")
            const relativeMatch = lowerPhrase.match(/(\d+)\s+(second|minute|hour|day|week)s?/i);

            if (relativeMatch) {
                const value = parseInt(relativeMatch[1], 10);
                const unit = relativeMatch[2];
                targetTime = new Date(now.getTime());

                switch (unit) {
                    case 'second':
                        targetTime.setSeconds(now.getSeconds() + value);
                        break;
                    case 'minute':
                        targetTime.setMinutes(now.getMinutes() + value);
                        break;
                    case 'hour':
                        targetTime.setHours(now.getHours() + value);
                        break;
                    case 'day':
                        targetTime.setDate(now.getDate() + value);
                        break;
                    case 'week':
                        targetTime.setDate(now.getDate() + (value * 7));
                        break;
                    default:
                        return null;
                }
                
                if (targetTime.getTime() > now.getTime()) {
                    setStatus(`Parsed time: ${formatTime(targetTime)} (Relative to now).`, false);
                    return targetTime.getTime();
                }
            }

            // 2. Specific Time/Date Parsing (e.g., "tomorrow at 5pm", "October 25 at 11am", "4:30 PM")
            try {
                let parsedDate = new Date(phrase);
                
                if (!isNaN(parsedDate.getTime())) {
                    if (parsedDate.getTime() <= now.getTime()) {
                        // If only a time was specified (e.g., "5 PM"), set it for tomorrow.
                        const timeOnly = parsedDate.toDateString() === now.toDateString();
                        if (timeOnly) {
                            parsedDate.setDate(parsedDate.getDate() + 1);
                        } else {
                            // If a full date was specified in the past, treat it as invalid.
                            return null;
                        }
                    }
                    targetTime = parsedDate;
                }
            } catch (e) {
                // Ignore date parsing errors
            }

            if (targetTime && targetTime.getTime() > now.getTime()) {
                setStatus(`Parsed time: ${formatTime(targetTime)} (Specific date/time).`, false);
                return targetTime.getTime();
            }

            // If all parsing fails
            setStatus(`Couldn't understand the time phrase "${phrase}". Please be more specific.`, true);
            return null;
        };

        // --- UI Rendering ---

        /**
         * Renders the current list of reminders to the DOM.
         */
        const renderReminders = () => {
            REMINDERS_LIST.innerHTML = '';
            
            // Filter out old reminders (optional cleanup for display)
            const activeReminders = reminders.filter(r => r.timestamp > Date.now()); 
            
            if (activeReminders.length === 0) {
                REMINDERS_LIST.innerHTML = '<p id="no-reminders" class="text-center text-gray-500 p-4 bg-white rounded-lg shadow-md">No reminders set yet.</p>';
                return;
            }

            activeReminders.forEach(r => {
                const now = Date.now();
                const isPast = r.timestamp < now; // Although filtered, keep logic for edge cases

                const reminderElement = document.createElement('div');
                reminderElement.className = `p-4 flex items-center justify-between rounded-lg shadow-md ${isPast ? 'bg-gray-200 opacity-60' : 'bg-white hover:shadow-lg transition duration-150'}`;
                reminderElement.innerHTML = `
                    <div>
                        <p class="font-medium text-gray-800 break-words">${r.text}</p>
                        <p class="text-xs ${isPast ? 'text-red-500 font-semibold' : 'text-indigo-500'} mt-1">
                            ${isPast ? 'Past Due' : formatTime(r.timestamp)}
                        </p>
                    </div>
                    <button data-id="${r.id}" class="delete-btn text-gray-400 hover:text-red-600 ml-4 p-2 transition duration-150">
                        <i class="fas fa-trash-alt"></i>
                    </button>
                `;
                REMINDERS_LIST.appendChild(reminderElement);
            });

            // Attach delete listeners
            document.querySelectorAll('.delete-btn').forEach(button => {
                button.onclick = (e) => {
                    const id = e.currentTarget.getAttribute('data-id');
                    deleteReminder(id);
                };
            });
        };

        // --- Alarm and Snooze Logic ---

        let currentAlarmId = null;
        let utterance = null;

        /**
         * Shows the alarm modal and triggers speech synthesis.
         * @param {object} reminder The reminder object.
         */
        const showAlarm = (reminder) => {
            currentAlarmId = reminder.id;
            ALARM_TEXT.textContent = reminder.text;

            ALARM_MODAL.classList.remove('hidden');
            ALARM_MODAL.classList.add('flex');
            // Animate in
            setTimeout(() => {
                MODAL_CONTENT.classList.remove('scale-95', 'opacity-0');
                MODAL_CONTENT.classList.add('scale-100', 'opacity-100');
            }, 10);

            // Read the reminder text aloud
            if ('speechSynthesis' in window) {
                window.speechSynthesis.cancel();
                utterance = new SpeechSynthesisUtterance(`Reminder: ${reminder.text}`);
                window.speechSynthesis.speak(utterance);
            }
        };

        /**
         * Hides the alarm modal.
         */
        const hideAlarm = () => {
            if ('speechSynthesis' in window && utterance) {
                window.speechSynthesis.cancel();
            }
            // Animate out
            MODAL_CONTENT.classList.remove('scale-100', 'opacity-100');
            MODAL_CONTENT.classList.add('scale-95', 'opacity-0');
            
            setTimeout(() => {
                ALARM_MODAL.classList.remove('flex');
                ALARM_MODAL.classList.add('hidden');
                currentAlarmId = null;
            }, 300); // Wait for animation to finish
        };

        // Event listener for Snooze
        SNOOZE_BTN.onclick = () => {
            if (!currentAlarmId) return;

            const durationInMinutes = parseInt(SNOOZE_DURATION_SELECT.value, 10);
            const snoozeTime = Date.now() + (durationInMinutes * 60 * 1000);
            
            // Find the reminder that triggered the alarm
            const reminderToSnooze = reminders.find(r => r.id === currentAlarmId);

            if (reminderToSnooze) {
                // Delete the original reminder
                deleteReminder(currentAlarmId);
                // Add a new reminder for the snooze time.
                addReminder(`(Snoozed) ${reminderToSnooze.text}`, snoozeTime);
            }

            hideAlarm();
            setStatus(`Snoozed! Will remind you again at ${formatTime(snoozeTime)}.`, false);
        };

        // Event listener for Dismiss
        DISMISS_BTN.onclick = () => {
            if (currentAlarmId) {
                deleteReminder(currentAlarmId);
            }
            hideAlarm();
            setStatus("Reminder dismissed.", false);
        };

        // --- Main Loop (Checking Alarms) ---

        const mainLoop = () => {
            const now = Date.now();
            reminders.forEach(r => {
                if (r.timestamp < now && r.id !== currentAlarmId) {
                    showAlarm(r);
                }
            });
        };

        // --- Input Handling ---

        /**
         * Handles manual text input submission.
         */
        const handleManualSet = () => {
            const inputContent = REMINDER_INPUT.value.trim();
            if (!inputContent) { return; }

            // Tries to match: "[task] (on|in|at) [time phrase]"
            // Using \s+ for robust space matching around prepositions.
            const match = inputContent.match(/(.+?)\s+(?:on|in|at)\s+(.+)/i);

            if (match && match.length === 3) {
                const text = match[1].trim();
                const timePhrase = match[2].trim();
                
                // Keep the input text if time parsing fails, so user can easily correct the time.
                REMINDER_INPUT.value = text + ' ' + timePhrase; 
                
                const time = parseReminderTime(timePhrase);
                
                if (time) {
                    addReminder(text, time);
                    REMINDER_INPUT.value = ''; // Clear only on successful addition
                }
            } else {
                setStatus("Input format error. Please use: [Task] [on/in/at] [Time Phrase]", true);
            }
        };


        // --- Speech Recognition ---

        const setupSpeechRecognition = () => {
            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;

            if (SpeechRecognition) {
                recognition = new SpeechRecognition();
                recognition.continuous = false;
                recognition.lang = 'en-US';
                recognition.interimResults = false;
                recognition.maxAlternatives = 1;

                MIC_BUTTON.onclick = () => {
                    try {
                        recognition.start();
                    } catch (e) {
                        // This prevents an error if recognition is already running
                        console.warn("Speech recognition already running or error starting:", e);
                    }
                };

                recognition.onstart = () => {
                    MIC_BUTTON.classList.add('listening');
                    MIC_STATUS.textContent = "Listening...";
                    setStatus("Please say: 'Set a reminder for [task] in 5 minutes'.", false);
                };

                recognition.onresult = (event) => {
                    const transcript = event.results[0][0].transcript;
                    processVoiceCommand(transcript);
                };

                recognition.onend = () => {
                    MIC_BUTTON.classList.remove('listening');
                    MIC_STATUS.textContent = "Click to Speak";
                };

                recognition.onerror = (event) => {
                    MIC_BUTTON.classList.remove('listening');
                    MIC_STATUS.textContent = "Click to Speak";
                    setStatus(`Voice error: ${event.error}. Please try again.`, true);
                };

            } else {
                MIC_BUTTON.disabled = true;
                MIC_STATUS.textContent = "Voice Not Supported";
                setStatus("Speech recognition is not supported in this browser. Please use manual entry.", true);
            }
        };

        /**
         * Processes the transcript from the voice command.
         * @param {string} transcript The recognized speech.
         */
        const processVoiceCommand = (transcript) => {
            const lowerTranscript = transcript.toLowerCase();

            // 1. Check for simple cancel/stop
            if (lowerTranscript.includes('cancel') || lowerTranscript.includes('stop')) {
                setStatus("Voice command cancelled.", false);
                return;
            }

            // 2. Main Reminder Pattern (Voice Command)
            const match = lowerTranscript.match(/set a reminder for (.+?) (?:on|in|at) (.+)/);
            
            if (match && match.length === 3) {
                const text = match[1].trim();
                const timePhrase = match[2].trim();
                const time = parseReminderTime(timePhrase); 
                
                if (time) {
                    addReminder(text, time);
                }
                return;
            }

            // 3. Fallback for Unmatched Commands
            setStatus(`I heard "${transcript}" but I couldn't understand that command. Please try "Set a reminder for [task] on October 25 at 11am."`, true);
        };


        // --- Initialization ---

        window.onload = () => {
            loadReminders(); // Load existing reminders from local storage
            
            SET_MANUAL_BTN.onclick = handleManualSet;
            REMINDER_INPUT.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    handleManualSet();
                }
            });

            setInterval(mainLoop, 1000); // Check alarms every second

            if ('speechSynthesis' in window) {
                window.speechSynthesis.getVoices(); // Populate voices early
            }
            setupSpeechRecognition();
        };

    </script>
</body>
</html>
