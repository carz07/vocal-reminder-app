<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vocal Reminder App</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            min-height: 100vh;
            background-color: #f7f9fc;
        }
        .mic-button {
            transition: all 0.2s ease;
        }
        .mic-button:hover {
            transform: scale(1.05);
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
        }
        .listening {
            animation: pulse-ring 1.5s infinite;
        }
        @keyframes pulse-ring {
            0% { box-shadow: 0 0 0 0 rgba(76, 29, 149, 0.4); }
            70% { box-shadow: 0 0 0 10px rgba(76, 29, 149, 0); }
            100% { box-shadow: 0 0 0 0 rgba(76, 29, 149, 0); }
        }
    </style>
</head>
<body class="p-4 sm:p-8">

    <div class="max-w-xl mx-auto bg-white shadow-xl rounded-2xl p-6 md:p-8">
        <h1 class="text-3xl font-bold text-gray-800 mb-6 flex items-center">
            <svg class="w-8 h-8 mr-2 text-indigo-600" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>
            Vocal Reminders
        </h1>
        
        <!-- Status & Microphone Section -->
        <div class="text-center mb-8">
            <p id="status-message" class="text-sm font-medium text-gray-500 mb-4 h-10 flex items-center justify-center bg-gray-50 rounded-lg p-2 transition-colors duration-300">
                Welcome! Click the microphone or type below to set reminders.
            </p>
            
            <!-- Microphone Button (Updated to a clearer outline icon) -->
            <button id="mic-button" class="mic-button bg-indigo-600 text-white p-5 rounded-full shadow-lg hover:bg-indigo-700 active:ring-4 active:ring-indigo-300 focus:outline-none focus:ring-4 focus:ring-indigo-300 disabled:opacity-50" aria-label="Start Voice Command">
                <!-- NEW Outline Microphone Icon -->
                <svg class="w-8 h-8" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 11a7 7 0 01-7 7v1a2 2 0 01-2 2h4a2 2 0 01-2-2v-1a7 7 0 01-7-7zM8 11V5a4 4 0 018 0v6a4 4 0 01-8 0z"/>
                </svg>
            </button>
            <p id="mic-status" class="mt-3 text-indigo-600 font-semibold hidden">Listening...</p>
        </div>

        <!-- Manual Input Section -->
        <div class="mb-8 border-t pt-6">
            <h2 class="text-xl font-semibold text-gray-700 mb-3">Manual Reminder</h2>
            <div class="flex flex-col sm:flex-row space-y-3 sm:space-y-0 sm:space-x-3 relative">
                <!-- Input field -->
                <div class="relative flex-grow">
                    <input type="text" id="reminder-input" placeholder='e.g., "Pay electricity bill in 3 hours" or "Call dentist on Monday at 9am"' class="w-full p-3 border border-gray-300 rounded-lg focus:ring-indigo-500 focus:border-indigo-500 shadow-sm">
                </div>
                
                <!-- Corrected Button: Pen Icon (UNCHANGED) -->
                <button id="set-manual-btn" class="flex items-center justify-center bg-indigo-500 text-white p-3 rounded-lg shadow-md hover:bg-indigo-600 transition duration-150 active:bg-indigo-700 disabled:opacity-50 w-full sm:w-auto" title="Set Reminder">
                    <!-- Pen/Edit Icon -->
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15.232 5.232l3.536 3.536m-2.036-5.036a2.5 2.5 0 113.536 3.536L6.5 21.036H3v-3.572L16.732 3.732z"></path></svg>
                </button>
            </div>
        </div>

        <!-- Reminders List -->
        <div>
            <h2 class="text-xl font-semibold text-gray-700 mb-3">Upcoming Reminders (<span id="reminder-count">0</span>)</h2>
            <ul id="reminders-list" class="space-y-4">
                <!-- Reminders will be rendered here -->
            </ul>
            <p id="no-reminders" class="text-center text-gray-400 mt-4 hidden">No reminders set yet. Time to get organized!</p>
        </div>
    </div>

    <!-- Alarm/Action Modal (Hidden by Default) -->
    <div id="alarm-modal" class="hidden fixed inset-0 bg-gray-900 bg-opacity-75 flex items-center justify-center p-4 z-50">
        <div class="bg-white rounded-xl shadow-2xl p-6 w-full max-w-sm">
            <div class="text-center">
                <svg class="w-12 h-12 text-yellow-500 mx-auto mb-4" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z"></path></svg>
                <h3 class="text-2xl font-bold text-gray-800 mb-2">Reminder Alert!</h3>
                <p id="modal-reminder-text" class="text-gray-600 mb-4 font-medium italic"></p>
                <p class="text-sm text-gray-500 mb-6">What would you like to do?</p>
            </div>

            <div class="flex justify-between space-x-3">
                <button id="modal-snooze-btn" class="flex-1 py-3 px-4 bg-yellow-500 text-white font-semibold rounded-lg shadow-md hover:bg-yellow-600 transition duration-150 active:bg-yellow-700">
                    Snooze
                </button>
                <button id="modal-dismiss-btn" class="flex-1 py-3 px-4 bg-green-600 text-white font-semibold rounded-lg shadow-md hover:bg-green-700 transition duration-150 active:bg-green-800">
                    Dismiss
                </button>
            </div>
        </div>
    </div>

    <!-- Snooze Duration Modal (Hidden by Default) -->
    <div id="snooze-modal" class="hidden fixed inset-0 bg-gray-900 bg-opacity-75 flex items-center justify-center p-4 z-50">
        <div class="bg-white rounded-xl shadow-2xl p-6 w-full max-w-sm">
            <div class="text-center">
                <h3 class="text-xl font-bold text-gray-800 mb-4">Snooze For...</h3>
                <div id="snooze-options" class="grid grid-cols-2 gap-3">
                    <!-- Snooze buttons inserted here by JS -->
                </div>
                <button id="snooze-modal-close" class="mt-6 py-2 px-4 bg-gray-200 text-gray-700 font-semibold rounded-lg hover:bg-gray-300 transition duration-150">
                    Cancel
                </button>
            </div>
        </div>
    </div>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, onSnapshot, setDoc, deleteDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        import { setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";


        // ---------------------------------------------------------------------
        // ðŸš¨ CRITICAL: FIREBASE SECURITY RULES FIX (Permission Denied Error) ðŸš¨
        // ---------------------------------------------------------------------
        // Reminder: Ensure these rules are deployed in Firebase Console to allow saving/loading data:
        /*
        rules_version = '2';
        service cloud.firestore {
          match /databases/{database}/documents {
            match /artifacts/{appId}/public/data/reminders/{userId} {
              allow read, write: if request.auth != null && request.auth.uid == userId;
            }
          }
        }
        */

        // ---------------------------------------------------------------------
        // ðŸš¨ IMPORTANT: CONFIGURATION FOR EXTERNAL DEPLOYMENT (e.g., GitHub) ðŸš¨
        // ---------------------------------------------------------------------

        const EXTERNAL_FIREBASE_CONFIG = {
            // apiKey: "YOUR_API_KEY",
            // authDomain: "YOUR_AUTH_DOMAIN",
            // projectId: "YOUR_PROJECT_ID",
            // ... other fields
        };
        const EXTERNAL_APP_ID = 'github-reminder-app'; 

        // ---------------------------------------------------------------------
        // --- Firebase Setup ---

        setLogLevel('Debug');
        
        // Prioritize Canvas variables, fall back to external config
        const isCanvasEnvironment = typeof __firebase_config !== 'undefined' && typeof __app_id !== 'undefined';
        
        const appId = isCanvasEnvironment ? __app_id : EXTERNAL_APP_ID;
        let firebaseConfig = {};

        if (isCanvasEnvironment) {
            try {
                firebaseConfig = JSON.parse(__firebase_config);
            } catch (e) {
                console.error("Error parsing Canvas Firebase config.", e);
            }
        } else if (Object.keys(EXTERNAL_FIREBASE_CONFIG).length > 0) {
            firebaseConfig = EXTERNAL_FIREBASE_CONFIG;
        }

        let app, db, auth, userId = null;
        let reminders = [];
        let currentAlarmId = null; 
        let isAuthReady = false;
        let isFirebaseActive = Object.keys(firebaseConfig).length > 0;

        if (isFirebaseActive) {
            try {
                app = initializeApp(firebaseConfig);
                db = getFirestore(app);
                auth = getAuth(app);
            } catch (e) {
                console.error("Error initializing Firebase:", e);
                isFirebaseActive = false; 
            }
        } else {
             console.warn("Firebase config not available. App will run in non-persistent (Local Storage) mode.");
        }


        // --- DOM Elements ---
        const STATUS_MESSAGE = document.getElementById('status-message');
        const MIC_BUTTON = document.getElementById('mic-button');
        const MIC_STATUS = document.getElementById('mic-status');
        const REMINDER_INPUT = document.getElementById('reminder-input');
        const SET_MANUAL_BTN = document.getElementById('set-manual-btn');
        const REMINDERS_LIST = document.getElementById('reminders-list');
        const REMINDER_COUNT = document.getElementById('reminder-count');
        const NO_REMINDERS = document.getElementById('no-reminders');

        const ALARM_MODAL = document.getElementById('alarm-modal');
        const MODAL_REMINDER_TEXT = document.getElementById('modal-reminder-text');
        const MODAL_SNOOZE_BTN = document.getElementById('modal-snooze-btn');
        const MODAL_DISMISS_BTN = document.getElementById('modal-dismiss-btn');

        const SNOOZE_MODAL = document.getElementById('snooze-modal');
        const SNOOZE_OPTIONS_CONTAINER = document.getElementById('snooze-options');
        const SNOOZE_MODAL_CLOSE = document.getElementById('snooze-modal-close');

        // --- Core Constants for Snooze Fix ---
        const FIVE_SECONDS_MS = 5 * 1000;
        const ONE_MINUTE_MS = 1 * 60 * 1000;
        const FIVE_MINUTES_MS = 5 * 60 * 1000;
        const TEN_MINUTES_MS = 10 * 60 * 1000;

        const SNOOZE_DURATIONS = [
            { label: "5 Seconds", ms: FIVE_SECONDS_MS },
            { label: "1 Minute", ms: ONE_MINUTE_MS },
            { label: "5 Minutes", ms: FIVE_MINUTES_MS },
            { label: "10 Minutes", ms: TEN_MINUTES_MS },
        ];


        // --- Utility Functions ---

        /** Sets the status message on the screen. */
        const setStatus = (message, isError = false) => {
            STATUS_MESSAGE.textContent = message;
            STATUS_MESSAGE.classList.toggle('bg-red-100', isError);
            STATUS_MESSAGE.classList.toggle('text-red-700', isError);
            STATUS_MESSAGE.classList.toggle('bg-gray-50', !isError);
            STATUS_MESSAGE.classList.toggle('text-gray-500', !isError);
            if (isFirebaseActive && !isAuthReady && !isError) {
                 // Subtle reminder that we're waiting on auth
                 STATUS_MESSAGE.textContent = `[Loading] ${message}`;
            }
        };

        /** Attempts to parse a time phrase using a very simple logic. */
        const parseReminderTime = (phrase) => {
            const now = Date.now();
            let date = new Date(now);
            const lowerPhrase = phrase.toLowerCase();

            // Simple "in X [unit]" pattern
            const inMatch = lowerPhrase.match(/in (\d+) (second|minute|hour|day|week|month)s?/);
            if (inMatch) {
                const num = parseInt(inMatch[1]);
                const unit = inMatch[2];
                switch (unit) {
                    case 'second': date.setSeconds(date.getSeconds() + num); break;
                    case 'minute': date.setMinutes(date.getMinutes() + num); break;
                    case 'hour': date.setHours(date.getHours() + num); break;
                    case 'day': date.setDate(date.getDate() + num); break;
                    case 'week': date.setDate(date.getDate() + (num * 7)); break;
                    case 'month': date.setMonth(date.getMonth() + num); break;
                }
                return date.getTime();
            }

            // Simple "at Xam/pm" pattern (for today/tomorrow only)
            const timeMatch = lowerPhrase.match(/at (\d+)(?::(\d+))?\s*(am|pm)/);
            if (timeMatch) {
                let hours = parseInt(timeMatch[1]);
                const minutes = timeMatch[2] ? parseInt(timeMatch[2]) : 0;
                const ampm = timeMatch[3];

                if (ampm === 'pm' && hours < 12) hours += 12;
                if (ampm === 'am' && hours === 12) hours = 0; // Midnight 12 am

                date.setHours(hours, minutes, 0, 0);

                // If the time is already passed today, set it for tomorrow
                if (date.getTime() <= now) {
                    date.setDate(date.getDate() + 1);
                }
                return date.getTime();
            }

            // Fallback: If it's a date string, try parsing it directly (e.g., "October 25 at 11am")
            const parsedDate = new Date(phrase);
            if (!isNaN(parsedDate) && parsedDate.getTime() > now) {
                return parsedDate.getTime();
            }

            // If all parsing fails, return null
            return null;
        };


        /** Saves reminders to Firestore (Public Collection) or localStorage as fallback. */
        const saveReminders = (list) => {
            if (isFirebaseActive && userId) {
                // Public data path: /artifacts/{appId}/public/data/reminders/{userId}
                const docRef = doc(db, 'artifacts', appId, 'public', 'data', 'reminders', userId);
                try {
                    setDoc(docRef, { data: JSON.stringify(list) }, { merge: true });
                } catch (e) {
                    console.error("Error saving reminders to Firestore:", e);
                }
            } else {
                localStorage.setItem('reminders', JSON.stringify(list));
            }
        };


        /** Adds a new reminder. */
        const addReminder = (text, time) => {
            const newReminder = {
                id: crypto.randomUUID(),
                text: text,
                time: time,
                createdAt: Date.now(),
            };

            const updatedReminders = [...reminders, newReminder].sort((a, b) => a.time - b.time);
            reminders = updatedReminders;
            saveReminders(reminders);
            setStatus(`Reminder set: "${text}" for ${new Date(time).toLocaleString()}`);
        };

        /** Snoozes a reminder for the given duration in milliseconds. */
        const snoozeReminder = (id, durationMs) => {
            ALARM_MODAL.classList.add('hidden'); // Close main alarm modal first
            SNOOZE_MODAL.classList.add('hidden'); // Ensure snooze modal is also closed

            const index = reminders.findIndex(r => r.id === id);

            if (index !== -1) {
                const reminder = reminders[index];
                
                const newTime = Date.now() + durationMs;
                reminder.time = newTime;
                
                // Keep the reminder from re-alarming immediately
                reminder.isSnoozed = true; 

                // Resort and save
                const updatedReminders = reminders.sort((a, b) => a.time - b.time);
                reminders = updatedReminders;
                saveReminders(reminders);
                
                const minutes = Math.round(durationMs / 60000); 
                let statusMsg = `Reminder "${reminder.text}" snoozed for `;

                if (durationMs < ONE_MINUTE_MS) {
                    statusMsg += `${durationMs / 1000} seconds.`;
                } else if (minutes === 1) {
                    statusMsg += `1 minute.`;
                } else {
                    statusMsg += `${minutes} minutes.`;
                }

                setStatus(statusMsg);
                renderReminders();
                currentAlarmId = null;
            }
        };

        /** Deletes a reminder. */
        const deleteReminder = (id) => {
            const updatedReminders = reminders.filter(r => r.id !== id);
            reminders = updatedReminders;
            saveReminders(reminders);
            renderReminders();
            setStatus('Reminder dismissed/deleted.');

            if (currentAlarmId === id) {
                ALARM_MODAL.classList.add('hidden');
                SNOOZE_MODAL.classList.add('hidden');
                currentAlarmId = null;
            }
        };


        // --- UI Rendering ---

        /** Renders the list of reminders. */
        const renderReminders = () => {
            REMINDERS_LIST.innerHTML = '';

            if (reminders.length === 0) {
                REMINDERS_LIST.classList.add('hidden');
                NO_REMINDERS.classList.remove('hidden');
            } else {
                REMINDERS_LIST.classList.remove('hidden');
                NO_REMINDERS.classList.add('hidden');
            }

            REMINDER_COUNT.textContent = reminders.length;

            reminders.forEach(reminder => {
                const li = document.createElement('li');
                li.className = 'flex justify-between items-center p-4 bg-white rounded-xl shadow border border-gray-100 transition duration-150 hover:shadow-lg';
                
                const timeString = new Date(reminder.time).toLocaleString('en-US', {
                    month: 'short',
                    day: 'numeric',
                    hour: 'numeric',
                    minute: '2-digit',
                    hour12: true
                });

                li.innerHTML = `
                    <div class="flex flex-col min-w-0 pr-4">
                        <p class="text-sm font-semibold text-gray-800 truncate">${reminder.text}</p>
                        <p class="text-xs text-indigo-600 mt-1 font-medium">${timeString}</p>
                    </div>
                    <button data-id="${reminder.id}" class="delete-btn text-red-500 hover:text-red-700 p-2 rounded-full transition duration-150" aria-label="Delete Reminder">
                        <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
                    </button>
                `;
                REMINDERS_LIST.appendChild(li);
            });

            // Attach listeners to newly created delete buttons
            document.querySelectorAll('.delete-btn').forEach(button => {
                button.onclick = () => {
                    const id = button.getAttribute('data-id');
                    deleteReminder(id);
                };
            });
        };

        /** Renders the snooze options in the dedicated modal. */
        const renderSnoozeOptions = () => {
            SNOOZE_OPTIONS_CONTAINER.innerHTML = '';
            SNOOZE_DURATIONS.forEach(option => {
                const button = document.createElement('button');
                button.className = 'py-3 px-4 bg-indigo-100 text-indigo-700 font-semibold rounded-lg hover:bg-indigo-200 transition duration-150';
                button.textContent = option.label;
                button.onclick = () => {
                    if (currentAlarmId) {
                        snoozeReminder(currentAlarmId, option.ms);
                    }
                };
                SNOOZE_OPTIONS_CONTAINER.appendChild(button);
            });
        };

        // --- Alarm and Modal Control ---

        /** Checks for reminders that are due. */
        const mainLoop = () => {
            if (currentAlarmId) return; // Don't check if an alarm is already showing

            const now = Date.now();
            const dueReminder = reminders.find(r => r.time <= now);

            if (dueReminder) {
                currentAlarmId = dueReminder.id;
                MODAL_REMINDER_TEXT.textContent = dueReminder.text;
                ALARM_MODAL.classList.remove('hidden');

                if ('speechSynthesis' in window) {
                    const utterance = new SpeechSynthesisUtterance(`Reminder: ${dueReminder.text}`);
                    utterance.voice = window.speechSynthesis.getVoices().find(v => v.lang === 'en-US' && v.name.includes('Google') || v.name.includes('Alex')) || null;
                    window.speechSynthesis.speak(utterance);
                }
            }
        };

        // --- Event Handlers ---

        const handleManualSet = () => {
            const input = REMINDER_INPUT.value.trim();
            if (!input) {
                setStatus('Please enter a reminder phrase.', true);
                return;
            }

            // Simple extraction: assume the first part is text, the rest is time.
            const parts = input.match(/^(.+?)\s+(?:on|in|at)\s+(.+)$/i);

            let text = input;
            let timePhrase = '';
            
            if (parts && parts.length === 3) {
                text = parts[1].trim();
                timePhrase = parts[2].trim();
            } else {
                // Fallback for simple "in X minutes" which might not use 'in' etc.
                const fallbackMatch = input.match(/^(.*?)\s+in\s+(.+)$/i);
                if (fallbackMatch && fallbackMatch.length === 3) {
                     text = fallbackMatch[1].trim();
                     timePhrase = 'in ' + fallbackMatch[2].trim();
                } else {
                     setStatus('Please include a time phrase like "in 5 minutes" or "on 10/25 at 11am".', true);
                     return;
                }
            }

            const time = parseReminderTime(timePhrase);

            if (time) {
                addReminder(text, time);
                REMINDER_INPUT.value = ''; // Clear input
            } else {
                setStatus(`Couldn't understand the time phrase "${timePhrase}". Please be more specific.`, true);
            }
        };
        
        // Modal button listeners
        MODAL_DISMISS_BTN.onclick = () => {
            if (currentAlarmId) {
                deleteReminder(currentAlarmId);
            }
        };
        
        MODAL_SNOOZE_BTN.onclick = () => {
            ALARM_MODAL.classList.add('hidden');
            SNOOZE_MODAL.classList.remove('hidden');
        };

        SNOOZE_MODAL_CLOSE.onclick = () => {
             SNOOZE_MODAL.classList.add('hidden');
             ALARM_MODAL.classList.remove('hidden'); // Go back to the main alarm modal
        };


        // --- Speech Recognition ---
        let recognition = null;
        let isListening = false;
        
        const setupSpeechRecognition = () => {
             if (!('webkitSpeechRecognition' in window)) {
                setStatus("Speech recognition not supported in this browser.", true);
                MIC_BUTTON.disabled = true;
                return;
            }

            recognition = new webkitSpeechRecognition();
            recognition.continuous = false;
            recognition.interimResults = false;
            recognition.lang = 'en-US';

            recognition.onstart = () => {
                isListening = true;
                MIC_BUTTON.classList.add('listening');
                MIC_STATUS.classList.remove('hidden');
                setStatus("Listening... Speak your reminder now.");
            };

            recognition.onend = () => {
                isListening = false;
                MIC_BUTTON.classList.remove('listening');
                MIC_STATUS.classList.add('hidden');
            };

            recognition.onerror = (event) => {
                setStatus(`Speech recognition error: ${event.error}`, true);
                isListening = false;
                MIC_BUTTON.classList.remove('listening');
                MIC_STATUS.classList.add('hidden');
            };

            recognition.onresult = (event) => {
                if (event.results.length > 0) {
                    const transcript = event.results[0][0].transcript;
                    handleVoiceCommand(transcript);
                }
            };

            recognition.onend = () => {
                isListening = false;
                MIC_BUTTON.classList.remove('listening');
                MIC_STATUS.classList.add('hidden');
            };

            MIC_BUTTON.onclick = () => {
                if (!isListening) {
                    recognition.start();
                } else {
                    recognition.stop();
                }
            };
        };


        /** Handles incoming voice transcript. */
        const handleVoiceCommand = (transcript) => {
            const lowerTranscript = transcript.toLowerCase().trim();
            setStatus(`Processing command: "${transcript}"...`);

            // 1. Simple reminder command (Voice Command)
            const match = lowerTranscript.match(/set a reminder for (.+?) (?:on|in|at) (.+)/);
            
            if (match && match.length === 3) {
                const text = match[1].trim();
                const timePhrase = match[2].trim();
                const time = parseReminderTime(timePhrase);
                
                if (time) {
                    addReminder(text, time);
                } else {
                     setStatus(`I understood the task, but not the time: "${timePhrase}"`, true);
                }
                return;
            }

            // 2. Fallback for Unmatched Commands
            setStatus(`I heard "${transcript}" but I couldn't understand that command. Please try "Set a reminder for [task] on October 25 at 11am."`, true);
        };


        // --- Firestore Real-Time Listener ---

        const setupFirestoreListener = (currentUserId) => {
            if (isFirebaseActive && currentUserId) {
                // Public data path: /artifacts/{appId}/public/data/reminders/{userId}
                const docRef = doc(db, 'artifacts', appId, 'public', 'data', 'reminders', currentUserId);
                
                onSnapshot(docRef, (doc) => {
                    if (doc.exists() && doc.data().data) {
                        try {
                            const fetchedList = JSON.parse(doc.data().data);
                            if (JSON.stringify(fetchedList) !== JSON.stringify(reminders)) {
                                reminders = fetchedList;
                                renderReminders();
                            }
                        } catch (e) {
                            console.error("Error parsing Firestore reminder data:", e);
                            reminders = [];
                            renderReminders();
                        }
                    } else {
                         reminders = [];
                         renderReminders();
                    }
                }, (error) => {
                    console.error("Error listening to Firestore:", error);
                    // Crucial: If we get a permission error here, it means the Firestore rules are wrong.
                    if (error.code === 'permission-denied') {
                         setStatus("Error: Permission denied. Please check your Firestore Security Rules.", true);
                    } else {
                         setStatus("Error connecting to real-time database.", true);
                    }
                });
            } else {
                // Load from localStorage if Firebase is unavailable
                const storedReminders = localStorage.getItem('reminders');
                if (storedReminders) {
                    try {
                        reminders = JSON.parse(storedReminders);
                    } catch(e) {
                        console.error("Error parsing localStorage data.", e);
                        reminders = [];
                    }
                }
                renderReminders();
            }
        };

        // --- Initialization --
        
        window.onload = () => {
            // Firebase Auth Setup
            if (isFirebaseActive && auth) {
                onAuthStateChanged(auth, async (user) => {
                    if (user) {
                        userId = user.uid;
                        setStatus(`Authenticated as user: ${userId.substring(0, 8)}...`);
                    } else {
                        // Attempt to use initial token (Canvas) or sign in anonymously (External)
                        try {
                            const token = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;
                            if (token) {
                                await signInWithCustomToken(auth, token);
                            } else {
                                await signInAnonymously(auth);
                            }
                        } catch (error) {
                            console.error("Error signing in:", error);
                            setStatus("Authentication failed. App running in non-persistent mode.", true);
                            isFirebaseActive = false;
                        }
                    }
                    
                    // Proceed only when we have a userId and we are ready to listen
                    if (userId && !isAuthReady) {
                        isAuthReady = true;
                        setupFirestoreListener(userId);
                    }
                    
                    // Fallback if auth fails but we are supposed to be active
                    if (!userId && isFirebaseActive) {
                         // This case shouldn't happen if auth setup works, but ensures we don't hang.
                         setStatus("Authentication failed. Check console for details.", true);
                    }
                });
            }


            // Set up UI listeners
            SET_MANUAL_BTN.onclick = handleManualSet;
            REMINDER_INPUT.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    handleManualSet();
                }
            });

            // Start the background loop for checking alarms
            setInterval(mainLoop, 1000); 

            // Initialize speech and UI
            if ('speechSynthesis' in window) {
                window.speechSynthesis.getVoices();
            }
            setupSpeechRecognition();
            renderSnoozeOptions(); // Populate the snooze modal
            
            // If Firebase is disabled, run the localStorage fallback initialization now.
            if (!isFirebaseActive) {
                 setupFirestoreListener(null); // Triggers localStorage load
                 setStatus("Welcome! (Database is disabled. Reminders are only saved in your browser.)");
            }

        };
    </script>
</body>
</html>
